\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}

% Colors for syntax highlighting
\definecolor{commentgreen}{RGB}{34,139,34}
\definecolor{stringcolor}{RGB}{208,76,239}
\definecolor{keywordcolor}{RGB}{0,0,255}
\definecolor{backgroundcolor}{RGB}{248,248,248}
\definecolor{numbercolor}{RGB}{128,128,128}

% Listings configuration for SystemVerilog
\lstdefinelanguage{SystemVerilog}{
  alsoletter={@},
  morekeywords={
    module, endmodule, input, output, inout, wire, reg, logic, bit,
    always, initial, begin, end, if, else, case, endcase, for, while,
    function, endfunction, task, endtask, return, automatic, static,
    class, endclass, new, extends, virtual, pure, extern, this,
    typedef, struct, enum, union, interface, endinterface,
    fork, join, join_any, join_none, disable,
    rand, randc, constraint, randomize, covergroup, endgroup, coverpoint,
    bins, import, export, ref, const, local, protected, string, int,
    real, void, assert, assume, cover, property, sequence,
    $display, $time, $sformatf, $error, wait
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\lstset{
  language=SystemVerilog,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{keywordcolor}\bfseries,
  commentstyle=\color{commentgreen}\itshape,
  stringstyle=\color{stringcolor},
  numberstyle=\tiny\color{numbercolor},
  backgroundcolor=\color{backgroundcolor},
  frame=single,
  rulecolor=\color{black!30},
  numbers=left,
  numbersep=8pt,
  tabsize=4,
  breaklines=true,
  breakatwhitespace=false,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=15pt,
  xrightmargin=5pt,
  aboveskip=10pt,
  belowskip=10pt,
}

% Hyperref setup
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
  pdftitle={SystemVerilog Functions and Tasks: Comprehensive Guide},
  pdfauthor={},
  pdfsubject={SystemVerilog Programming},
  pdfkeywords={SystemVerilog, Functions, Tasks, HDL, Verification},
  bookmarksnumbered=true,
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{SystemVerilog Functions and Tasks}
\fancyhead[R]{\thepage}
\fancyfoot[C]{Comprehensive Guide: Beginner to Advanced}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Title formatting
\titleformat{\section}
  {\normalfont\Large\bfseries\color{blue!70!black}}
  {\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{blue!50!black}}
  {\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries\color{blue!30!black}}
  {\thesubsubsection}{1em}{}

% Title
\title{
  \vspace{-2cm}
  \Huge\textbf{SystemVerilog Functions and Tasks} \\
  \LARGE Comprehensive Guide \\
  \Large From Beginner to Advanced
}
\author{}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This comprehensive guide covers SystemVerilog functions and tasks from beginner to advanced levels. Functions and tasks are fundamental building blocks in SystemVerilog that enable code reusability, modularity, and better organization. This document provides detailed explanations, practical examples, best practices, and common pitfalls to help developers master these essential programming constructs.
\end{abstract}

\tableofcontents
\newpage

% ============================================================================
\section{Introduction}

Functions and tasks are fundamental building blocks in SystemVerilog that enable code reusability, modularity, and better organization. While they share similarities, they serve different purposes and have distinct characteristics.

\subsection{Key Differences: Functions vs Tasks}

\begin{table}[H]
\centering
\begin{tabular}{|>{\raggedright}p{3.5cm}|>{\raggedright}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
\textbf{Feature} & \textbf{Functions} & \textbf{Tasks} \\
\hline
Return Value & Must return a value & Cannot return a value (use output/inout) \\
\hline
Timing Control & No delays allowed & Can contain delays (\#, @, wait) \\
\hline
Execution Time & Zero simulation time & Can consume simulation time \\
\hline
Task/Function Calls & Can call functions only & Can call both tasks and functions \\
\hline
Output Arguments & Single return value (SV allows output/ref) & Multiple outputs via output/inout \\
\hline
\end{tabular}
\caption{Functions vs Tasks Comparison}
\end{table}

% ============================================================================
\section{Beginner Level}

\subsection{Basic Functions}

Functions are used to compute and return a value. They execute in zero simulation time.

\subsubsection{Simple Function Syntax}

\begin{lstlisting}[caption={Basic Function Example}]
// Basic function declaration
function int add(int a, int b);
    return a + b;
endfunction

// Usage
module basic_function_example;
    int result;

    initial begin
        result = add(5, 3);
        $display("Result: %0d", result);  // Output: Result: 8
    end
endmodule
\end{lstlisting}

\subsubsection{Function with Automatic Storage}

The \texttt{automatic} keyword creates a new storage space for each function call, which is essential for recursive functions.

\begin{lstlisting}[caption={Automatic Function for Recursion}]
// Automatic function (recommended for recursive calls)
function automatic int factorial(int n);
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
endfunction

module factorial_example;
    initial begin
        $display("5! = %0d", factorial(5));  // Output: 5! = 120
    end
endmodule
\end{lstlisting}

\subsubsection{Void Functions}

SystemVerilog supports void functions that don't return a value, useful for operations with side effects.

\begin{lstlisting}[caption={Void Function Example}]
// Void function - doesn't return a value
function void print_message(string msg);
    $display("Message: %s", msg);
endfunction

module void_function_example;
    initial begin
        print_message("Hello, SystemVerilog!");
    end
endmodule
\end{lstlisting}

\subsection{Basic Tasks}

Tasks can contain timing controls and don't return values directly. They use output/inout parameters to return results.

\subsubsection{Simple Task Syntax}

\begin{lstlisting}[caption={Basic Task Example}]
// Basic task declaration
task display_values(input int a, input int b);
    $display("a = %0d, b = %0d", a, b);
endtask

module basic_task_example;
    initial begin
        display_values(10, 20);
    end
endmodule
\end{lstlisting}

\subsubsection{Task with Output Parameters}

\begin{lstlisting}[caption={Task with Output Parameter}]
// Task with output parameter
task multiply(input int a, input int b, output int result);
    result = a * b;
endtask

module task_output_example;
    int product;

    initial begin
        multiply(6, 7, product);
        $display("Product: %0d", product);  // Output: Product: 42
    end
endmodule
\end{lstlisting}

\subsubsection{Task with Timing Control}

One of the key advantages of tasks is the ability to include timing controls.

\begin{lstlisting}[caption={Task with Delay}]
// Task with delay
task wait_and_display(input int value, input int delay_ns);
    #delay_ns;  // Wait for specified time
    $display("Value after %0d ns: %0d", delay_ns, value);
endtask

module timing_task_example;
    initial begin
        $display("Time: %0t", $time);
        wait_and_display(100, 10);
        $display("Time: %0t", $time);
    end
endmodule
\end{lstlisting}

\subsection{Parameter Passing Modes}

SystemVerilog supports three parameter passing modes: \texttt{input}, \texttt{output}, and \texttt{inout}.

\begin{lstlisting}[caption={Parameter Passing Modes}]
module parameter_modes;
    int a, b, sum, diff;

    // Task with different parameter modes
    task calculate(
        input int x,      // Input only
        input int y,      // Input only
        output int s,     // Output only
        output int d      // Output only
    );
        s = x + y;
        d = x - y;
    endtask

    initial begin
        a = 15;
        b = 5;
        calculate(a, b, sum, diff);
        $display("Sum: %0d, Difference: %0d", sum, diff);
        // Output: Sum: 20, Difference: 10
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Intermediate Level}

\subsection{Functions with Default Arguments}

SystemVerilog allows default values for function arguments.

\begin{lstlisting}[caption={Function with Default Arguments}]
// Function with default arguments
function int power(int base, int exp = 2);
    int result = 1;
    for (int i = 0; i < exp; i++)
        result *= base;
    return result;
endfunction

module default_args_example;
    initial begin
        $display("3^2 = %0d", power(3));      // Uses default exp=2
        $display("2^5 = %0d", power(2, 5));   // Overrides default
    end
endmodule
\end{lstlisting}

\subsection{Functions with Output and Ref Arguments}

SystemVerilog allows functions to have output and ref (reference) arguments.

\subsubsection{Output Arguments}

\begin{lstlisting}[caption={Function with Output Argument}]
// Function with output argument
function int divide(int dividend, int divisor, output int remainder);
    remainder = dividend % divisor;
    return dividend / divisor;
endfunction

module function_output_example;
    int quotient, remainder;

    initial begin
        quotient = divide(17, 5, remainder);
        $display("17 / 5 = %0d remainder %0d", quotient, remainder);
        // Output: 17 / 5 = 3 remainder 2
    end
endmodule
\end{lstlisting}

\subsubsection{Reference Arguments (ref)}

The \texttt{ref} keyword enables pass-by-reference, allowing functions to modify arguments directly without copying.

\begin{lstlisting}[caption={Using ref for Pass-by-Reference}]
// Using ref for pass-by-reference
function void swap(ref int a, ref int b);
    int temp;
    temp = a;
    a = b;
    b = temp;
endfunction

module ref_argument_example;
    int x = 10, y = 20;

    initial begin
        $display("Before swap: x=%0d, y=%0d", x, y);
        swap(x, y);
        $display("After swap: x=%0d, y=%0d", x, y);
        // Output: Before swap: x=10, y=20
        //         After swap: x=20, y=10
    end
endmodule
\end{lstlisting}

\subsection{Automatic vs Static Functions/Tasks}

Understanding the difference between automatic and static storage is crucial for correct behavior.

\begin{lstlisting}[caption={Automatic vs Static Storage}]
module automatic_vs_static;

    // Static function (default) - single shared storage
    function int static_counter();
        static int count = 0;  // Retains value between calls
        count++;
        return count;
    endfunction

    // Automatic function - new storage for each call
    function automatic int auto_counter();
        int count = 0;  // Reinitialized each call
        count++;
        return count;
    endfunction

    initial begin
        // Static function
        $display("Static: %0d", static_counter());  // 1
        $display("Static: %0d", static_counter());  // 2
        $display("Static: %0d", static_counter());  // 3

        // Automatic function
        $display("Auto: %0d", auto_counter());  // 1
        $display("Auto: %0d", auto_counter());  // 1
        $display("Auto: %0d", auto_counter());  // 1
    end
endmodule
\end{lstlisting}

\subsection{Tasks with Automatic Storage (Reentrant Tasks)}

Automatic tasks allow concurrent calls, which is essential for parallel operations.

\begin{lstlisting}[caption={Reentrant Task Example}]
// Automatic task - allows concurrent calls
task automatic delay_display(input int id, input int delay_time);
    #delay_time;
    $display("Task %0d completed at time %0t", id, $time);
endtask

module reentrant_task_example;
    initial begin
        fork
            delay_display(1, 10);
            delay_display(2, 5);
            delay_display(3, 15);
        join
    end
endmodule
\end{lstlisting}

\subsection{Return Statement in Tasks}

In SystemVerilog, tasks can use the \texttt{return} statement to exit early.

\begin{lstlisting}[caption={Early Return in Task}]
task process_data(input int data);
    if (data < 0) begin
        $display("Error: Negative data");
        return;  // Early exit
    end

    // Process positive data
    $display("Processing data: %0d", data);
endtask

module task_return_example;
    initial begin
        process_data(10);   // Processes normally
        process_data(-5);   // Returns early
        process_data(20);   // Processes normally
    end
endmodule
\end{lstlisting}

\subsection{Class Methods (Functions and Tasks)}

Functions and tasks can be member methods of classes, providing object-oriented capabilities.

\begin{lstlisting}[caption={Class Methods Example}]
class Calculator;
    int accumulator;

    // Constructor
    function new();
        accumulator = 0;
    endfunction

    // Member function
    function void add(int value);
        accumulator += value;
    endfunction

    // Member task with delay
    task automatic delayed_multiply(input int value, input int delay_ns);
        #delay_ns;
        accumulator *= value;
    endtask

    // Function to get result
    function int get_result();
        return accumulator;
    endfunction
endclass

module class_method_example;
    Calculator calc;

    initial begin
        calc = new();
        calc.add(10);
        calc.add(5);
        $display("After additions: %0d", calc.get_result());  // 15

        calc.delayed_multiply(2, 10);
        #10;
        $display("After multiply: %0d", calc.get_result());   // 30
    end
endmodule
\end{lstlisting}

\subsection{Functions Returning Arrays and Structures}

SystemVerilog functions can return complex data types like arrays and structures.

\begin{lstlisting}[caption={Functions Returning Complex Types}]
// Function returning an array
function int[3:0] get_nibbles(bit [15:0] data);
    int result[3:0];
    for (int i = 0; i < 4; i++)
        result[i] = data[i*4 +: 4];
    return result;
endfunction

// Define a structure
typedef struct {
    int x;
    int y;
} point_t;

// Function returning a structure
function point_t create_point(int x_val, int y_val);
    point_t p;
    p.x = x_val;
    p.y = y_val;
    return p;
endfunction

module return_complex_types;
    int nibbles[3:0];
    point_t my_point;

    initial begin
        nibbles = get_nibbles(16'hABCD);
        $display("Nibbles: %h %h %h %h",
                 nibbles[0], nibbles[1], nibbles[2], nibbles[3]);

        my_point = create_point(100, 200);
        $display("Point: (%0d, %0d)", my_point.x, my_point.y);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Advanced Level}

\subsection{Virtual Functions (Polymorphism)}

Virtual functions enable polymorphism in SystemVerilog, allowing derived classes to override base class methods.

\begin{lstlisting}[caption={Polymorphism with Virtual Functions}]
// Base class with virtual function
class Shape;
    virtual function real area();
        return 0.0;
    endfunction

    virtual function void display();
        $display("Generic Shape, Area: %0f", area());
    endfunction
endclass

// Derived class - Circle
class Circle extends Shape;
    real radius;

    function new(real r);
        radius = r;
    endfunction

    virtual function real area();
        return 3.14159 * radius * radius;
    endfunction

    virtual function void display();
        $display("Circle, Radius: %0f, Area: %0f", radius, area());
    endfunction
endclass

// Derived class - Rectangle
class Rectangle extends Shape;
    real length, width;

    function new(real l, real w);
        length = l;
        width = w;
    endfunction

    virtual function real area();
        return length * width;
    endfunction

    virtual function void display();
        $display("Rectangle, Length: %0f, Width: %0f, Area: %0f",
                 length, width, area());
    endfunction
endclass

module polymorphism_example;
    Shape shapes[];
    Circle c;
    Rectangle r;

    initial begin
        c = new(5.0);
        r = new(4.0, 6.0);

        shapes = new[2];
        shapes[0] = c;
        shapes[1] = r;

        foreach(shapes[i]) begin
            shapes[i].display();  // Polymorphic call
        end
        // Output:
        // Circle, Radius: 5.000000, Area: 78.539750
        // Rectangle, Length: 4.000000, Width: 6.000000, Area: 24.000000
    end
endmodule
\end{lstlisting}

\subsection{Pure Virtual Functions (Abstract Classes)}

Pure virtual functions define abstract base classes that cannot be instantiated directly.

\begin{lstlisting}[caption={Abstract Classes with Pure Virtual Functions}]
// Abstract base class
virtual class AbstractProcessor;
    // Pure virtual function (must be overridden)
    pure virtual function void process(int data);

    // Concrete function
    function void log_operation(string msg);
        $display("[LOG] %s", msg);
    endfunction
endclass

// Concrete implementation
class DataProcessor extends AbstractProcessor;
    virtual function void process(int data);
        log_operation($sformatf("Processing data: %0d", data));
        // Processing logic here
    endfunction
endclass

module abstract_class_example;
    DataProcessor proc;

    initial begin
        proc = new();
        proc.process(42);
        // Output: [LOG] Processing data: 42
    end
endmodule
\end{lstlisting}

\subsection{Function Chaining and Fluent Interfaces}

Function chaining enables a fluent API style where methods return \texttt{this} for convenient chaining.

\begin{lstlisting}[caption={Fluent Interface Pattern}]
class FluentBuilder;
    int value;
    string name;

    function new();
        value = 0;
        name = "";
    endfunction

    // Functions return 'this' for chaining
    function FluentBuilder set_value(int v);
        value = v;
        return this;
    endfunction

    function FluentBuilder set_name(string n);
        name = n;
        return this;
    endfunction

    function void display();
        $display("Name: %s, Value: %0d", name, value);
    endfunction
endclass

module fluent_interface_example;
    FluentBuilder builder;

    initial begin
        builder = new();

        // Method chaining
        builder.set_name("MyObject")
               .set_value(100)
               .display();
        // Output: Name: MyObject, Value: 100
    end
endmodule
\end{lstlisting}

\subsection{Parameterized Functions and Tasks}

Functions and tasks can use module parameters for flexible, reusable code.

\begin{lstlisting}[caption={Parameterized Functions}]
module parameterized_example #(parameter WIDTH = 8);

    // Function using module parameter
    function bit [WIDTH-1:0] reverse_bits(bit [WIDTH-1:0] data);
        bit [WIDTH-1:0] result;
        for (int i = 0; i < WIDTH; i++)
            result[i] = data[WIDTH-1-i];
        return result;
    endfunction

    initial begin
        bit [WIDTH-1:0] data = 8'b10110010;
        bit [WIDTH-1:0] reversed;

        reversed = reverse_bits(data);
        $display("Original:  %b", data);
        $display("Reversed:  %b", reversed);
    end
endmodule

module test_parameterized;
    // 8-bit version
    parameterized_example #(.WIDTH(8)) inst8();

    // 16-bit version
    parameterized_example #(.WIDTH(16)) inst16();
endmodule
\end{lstlisting}

\subsection{Tasks with Fork-Join for Parallelism}

Tasks can use fork-join constructs to manage parallel operations.

\begin{lstlisting}[caption={Parallel Operations with Fork-Join}]
task automatic parallel_operations();
    fork
        begin
            #10 $display("[%0t] Operation 1 complete", $time);
        end
        begin
            #5 $display("[%0t] Operation 2 complete", $time);
        end
        begin
            #15 $display("[%0t] Operation 3 complete", $time);
        end
    join
    $display("[%0t] All parallel operations complete", $time);
endtask

task automatic parallel_with_join_any();
    fork
        begin
            #10 $display("[%0t] Fast operation done", $time);
        end
        begin
            #100 $display("[%0t] Slow operation done", $time);
        end
    join_any
    $display("[%0t] First operation completed", $time);
    disable fork;  // Kill remaining threads
endtask

module parallel_task_example;
    initial begin
        $display("=== Fork-Join Example ===");
        parallel_operations();

        $display("\n=== Fork-Join_any Example ===");
        parallel_with_join_any();
        #5 $display("[%0t] Continuing after join_any", $time);
    end
endmodule
\end{lstlisting}

\subsection{Extern Functions and Tasks}

The \texttt{extern} keyword allows separation of declaration and definition.

\begin{lstlisting}[caption={Extern Functions and Tasks}]
class DataProcessor;
    // Declaration only (extern)
    extern function void process(int data);
    extern task automatic delayed_process(int data, int delay);
endclass

// Definition outside class
function void DataProcessor::process(int data);
    $display("Processing: %0d", data);
endfunction

task automatic DataProcessor::delayed_process(int data, int delay);
    #delay;
    $display("[%0t] Delayed processing: %0d", $time, data);
endtask

module extern_example;
    DataProcessor proc;

    initial begin
        proc = new();
        proc.process(10);
        proc.delayed_process(20, 5);
    end
endmodule
\end{lstlisting}

\subsection{Recursive Functions with Memoization}

Memoization optimizes recursive functions by caching previously computed results.

\begin{lstlisting}[caption={Fibonacci with Memoization}]
class Fibonacci;
    static int cache[int];  // Associative array for memoization

    static function int calculate(int n);
        if (cache.exists(n))
            return cache[n];

        if (n <= 1) begin
            cache[n] = n;
            return n;
        end

        cache[n] = calculate(n-1) + calculate(n-2);
        return cache[n];
    endfunction
endclass

module fibonacci_example;
    initial begin
        for (int i = 0; i <= 10; i++)
            $display("Fib(%0d) = %0d", i, Fibonacci::calculate(i));
    end
endmodule
\end{lstlisting}

\subsection{DPI (Direct Programming Interface) Functions}

DPI allows calling C/C++ functions from SystemVerilog and vice versa.

\begin{lstlisting}[caption={DPI Example}]
// Import C function
import "DPI-C" function int c_add(input int a, input int b);
import "DPI-C" function void c_print_message(input string msg);

// Export SystemVerilog function to C
export "DPI-C" function sv_multiply;

function int sv_multiply(int a, int b);
    return a * b;
endfunction

module dpi_example;
    initial begin
        int result;

        // Call C function from SV
        result = c_add(10, 20);
        $display("C function result: %0d", result);

        c_print_message("Hello from SystemVerilog!");
    end
endmodule
\end{lstlisting}

\subsection{Constraint Functions}

Functions can be used within random constraints for advanced constraint modeling.

\begin{lstlisting}[caption={Constraint Functions}]
class ConstrainedData;
    rand bit [7:0] data;
    rand bit [3:0] nibble;

    // Constraint using function
    constraint valid_data {
        is_even(data);
        nibble inside {[0:10]};
    }

    // Function used in constraint
    function bit is_even(bit [7:0] value);
        return (value[0] == 0);
    endfunction
endclass

module constraint_function_example;
    ConstrainedData obj;

    initial begin
        obj = new();
        repeat(5) begin
            assert(obj.randomize());
            $display("Data: %0d (even), Nibble: %0d", obj.data, obj.nibble);
        end
    end
endmodule
\end{lstlisting}

\subsection{Coverage Functions}

Functions can be used to calculate and report functional coverage.

\begin{lstlisting}[caption={Functional Coverage with Functions}]
class CoverageCollector;
    bit [7:0] data;

    covergroup cg;
        data_cp: coverpoint data {
            bins low    = {[0:63]};
            bins medium = {[64:127]};
            bins high   = {[128:255]};
        }
    endgroup

    function new();
        cg = new();
    endfunction

    function void sample(bit [7:0] value);
        data = value;
        cg.sample();
    endfunction

    function real get_coverage();
        return cg.get_coverage();
    endfunction
endclass

module coverage_example;
    CoverageCollector collector;

    initial begin
        collector = new();

        // Sample various values
        collector.sample(10);
        collector.sample(100);
        collector.sample(200);

        $display("Coverage: %0f%%", collector.get_coverage());
    end
endmodule
\end{lstlisting}

\subsection{Macro-Based Function Generation}

Macros can generate repetitive function code, useful for creating property accessors.

\begin{lstlisting}[caption={Macro-Based Function Generation}]
// Macro to generate getter/setter functions
`define PROPERTY(type, name) \
    local type m_``name; \
    function void set_``name(type value); \
        m_``name = value; \
    endfunction \
    function type get_``name(); \
        return m_``name; \
    endfunction

class ConfigWithMacros;
    `PROPERTY(int, timeout)
    `PROPERTY(string, mode)
    `PROPERTY(bit, enable)
endclass

module macro_function_example;
    ConfigWithMacros cfg;

    initial begin
        cfg = new();

        cfg.set_timeout(1000);
        cfg.set_mode("fast");
        cfg.set_enable(1);

        $display("Timeout: %0d", cfg.get_timeout());
        $display("Mode: %s", cfg.get_mode());
        $display("Enable: %0d", cfg.get_enable());
    end
endmodule
\end{lstlisting}

\subsection{Tasks for Protocol Drivers}

Tasks are commonly used to implement protocol drivers in verification environments.

\begin{lstlisting}[caption={APB Protocol Driver}]
interface apb_if(input bit clk);
    logic [31:0] paddr;
    logic        psel;
    logic        penable;
    logic        pwrite;
    logic [31:0] pwdata;
    logic [31:0] prdata;
    logic        pready;
endinterface

class APB_Driver;
    virtual apb_if vif;

    function new(virtual apb_if vif);
        this.vif = vif;
    endfunction

    // APB write task
    task automatic write(bit [31:0] addr, bit [31:0] data);
        @(posedge vif.clk);
        vif.paddr   <= addr;
        vif.pwrite  <= 1;
        vif.pwdata  <= data;
        vif.psel    <= 1;

        @(posedge vif.clk);
        vif.penable <= 1;

        @(posedge vif.clk);
        wait(vif.pready);
        vif.psel    <= 0;
        vif.penable <= 0;

        $display("[%0t] APB Write: Addr=0x%h, Data=0x%h",
                 $time, addr, data);
    endtask

    // APB read task
    task automatic read(bit [31:0] addr, output bit [31:0] data);
        @(posedge vif.clk);
        vif.paddr   <= addr;
        vif.pwrite  <= 0;
        vif.psel    <= 1;

        @(posedge vif.clk);
        vif.penable <= 1;

        @(posedge vif.clk);
        wait(vif.pready);
        data = vif.prdata;
        vif.psel    <= 0;
        vif.penable <= 0;

        $display("[%0t] APB Read: Addr=0x%h, Data=0x%h",
                 $time, addr, data);
    endtask
endclass
\end{lstlisting}

% ============================================================================
\section{Best Practices}

\subsection{Use Automatic for Recursive or Reentrant Code}

Always use the \texttt{automatic} keyword for recursive functions and reentrant tasks to ensure proper behavior.

\begin{lstlisting}[caption={Proper Use of Automatic}]
// GOOD: Automatic for recursion
function automatic int recursive_sum(int n);
    if (n <= 0) return 0;
    return n + recursive_sum(n-1);
endfunction

// BAD: Static for recursion (causes issues)
function int bad_recursive_sum(int n);
    if (n <= 0) return 0;
    return n + bad_recursive_sum(n-1);  // Shares variables!
endfunction
\end{lstlisting}

\subsection{Prefer Functions Over Tasks When Possible}

Use functions for pure computations without timing, as they're more flexible and can be used in expressions.

\begin{lstlisting}[caption={Functions vs Tasks for Computation}]
// GOOD: Function for pure computation
function int max(int a, int b);
    return (a > b) ? a : b;
endfunction

// LESS IDEAL: Task for simple computation
task get_max(input int a, input int b, output int result);
    result = (a > b) ? a : b;
endtask
\end{lstlisting}

\subsection{Use Void Functions for Side Effects Only}

When a function doesn't need to return a value, use \texttt{void} to make the intent clear.

\begin{lstlisting}[caption={Void Functions for Side Effects}]
// GOOD: Clear intent
function void validate_config(Config cfg);
    assert(cfg.timeout > 0) else $error("Invalid timeout");
    assert(cfg.width inside {8, 16, 32}) else $error("Invalid width");
endfunction
\end{lstlisting}

\subsection{Document Function/Task Interfaces}

Always document the purpose, parameters, and return values of functions and tasks.

\begin{lstlisting}[caption={Well-Documented Function}]
/// Converts temperature from Celsius to Fahrenheit
/// @param celsius Temperature in Celsius
/// @return Temperature in Fahrenheit
function real celsius_to_fahrenheit(real celsius);
    return (celsius * 9.0/5.0) + 32.0;
endfunction
\end{lstlisting}

\subsection{Use Ref for Large Data Structures}

Use \texttt{ref} parameters to avoid copying large data structures, improving performance.

\begin{lstlisting}[caption={Using Ref for Large Structures}]
typedef struct {
    bit [31:0] data[1024];
    int size;
} large_packet_t;

// GOOD: Use ref to avoid copying
function void process_packet(ref large_packet_t pkt);
    for (int i = 0; i < pkt.size; i++)
        pkt.data[i] = ~pkt.data[i];
endfunction

// BAD: Copies entire structure
function void bad_process_packet(large_packet_t pkt);
    // ...
endfunction
\end{lstlisting}

\subsection{Keep Functions Pure When Possible}

Pure functions (without side effects) are easier to test, debug, and reason about.

\begin{lstlisting}[caption={Pure vs Impure Functions}]
// GOOD: Pure function (no side effects)
function int calculate_checksum(bit [7:0] data[]);
    int checksum = 0;
    foreach(data[i])
        checksum += data[i];
    return checksum;
endfunction

// LESS IDEAL: Function with side effects
function int calculate_and_log_checksum(bit [7:0] data[]);
    int checksum = 0;
    foreach(data[i])
        checksum += data[i];
    $display("Checksum: %0d", checksum);  // Side effect
    return checksum;
endfunction
\end{lstlisting}

% ============================================================================
\section{Common Pitfalls}

\subsection{Timing in Functions}

Functions cannot contain timing controls. Use tasks instead.

\begin{lstlisting}[caption={Timing Control Error}]
// ERROR: Cannot have delays in functions
function int bad_delayed_function(int value);
    #10;  // ILLEGAL!
    return value * 2;
endfunction

// CORRECT: Use task for timing
task delayed_operation(input int value, output int result);
    #10;
    result = value * 2;
endtask
\end{lstlisting}

\subsection{Task Calls in Functions}

Functions cannot call tasks because tasks may consume simulation time.

\begin{lstlisting}[caption={Task Call Error}]
task my_task();
    #10 $display("Task executing");
endtask

// ERROR: Functions cannot call tasks
function void bad_function();
    my_task();  // ILLEGAL!
endfunction

// CORRECT: Tasks can call tasks
task good_task();
    my_task();  // OK
endtask
\end{lstlisting}

\subsection{Forgetting Automatic for Recursion}

Static recursion shares variables between calls, leading to incorrect results.

\begin{lstlisting}[caption={Recursion Requires Automatic}]
// PROBLEMATIC: Static recursion
function int fibonacci(int n);
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);  // Shares variables!
endfunction

// CORRECT: Automatic recursion
function automatic int good_fibonacci(int n);
    if (n <= 1) return n;
    return good_fibonacci(n-1) + good_fibonacci(n-2);
endfunction
\end{lstlisting}

\subsection{Output Assignment Timing}

Always assign output parameters before returning, especially in early returns.

\begin{lstlisting}[caption={Output Assignment Issue}]
// PROBLEMATIC: Output not assigned before return
function int divide_with_remainder(int a, int b, output int rem);
    if (b == 0) return 0;  // rem not assigned!
    rem = a % b;
    return a / b;
endfunction

// CORRECT: Always assign outputs
function int good_divide_with_remainder(int a, int b, output int rem);
    if (b == 0) begin
        rem = 0;  // Assign output
        return 0;
    end
    rem = a % b;
    return a / b;
endfunction
\end{lstlisting}

\subsection{Modifying Input Arguments}

Input parameters are read-only and cannot be modified.

\begin{lstlisting}[caption={Input Modification Error}]
// BAD: Trying to modify input
function void process(input int value);
    value = value * 2;  // ILLEGAL! Inputs are read-only
endfunction

// CORRECT: Use output or ref
function void process_output(input int value, output int result);
    result = value * 2;
endfunction

function void process_ref(ref int value);
    value = value * 2;  // OK with ref
endfunction
\end{lstlisting}

\subsection{Ignoring Return Values}

While legal, ignoring return values can indicate a design issue.

\begin{lstlisting}[caption={Ignoring Return Values}]
function int compute();
    return 42;
endfunction

// LEGAL but potentially problematic
initial begin
    compute();  // Return value ignored
end

// BETTER: Use void if no return needed
function void compute_void();
    // Do work without return
endfunction
\end{lstlisting}

% ============================================================================
\section{Summary}

\subsection{When to Use Functions}

\begin{itemize}
    \item Pure computations without timing
    \item Need to return a single value
    \item Can be used in expressions
    \item Need to ensure zero simulation time
\end{itemize}

\subsection{When to Use Tasks}

\begin{itemize}
    \item Operations requiring timing control
    \item Multiple output values needed
    \item Calling other tasks
    \item Modeling hardware behavior with delays
\end{itemize}

\subsection{Key Takeaways}

\begin{enumerate}
    \item Use \texttt{automatic} for recursive or concurrent operations
    \item Use \texttt{ref} for large data structures to avoid copying
    \item Functions must execute in zero time; tasks can have delays
    \item Virtual functions enable polymorphism
    \item DPI enables C/C++ integration
    \item Proper use of functions/tasks improves code reusability and maintainability
\end{enumerate}

% ============================================================================
\section{Additional Resources}

For more information on SystemVerilog:

\begin{itemize}
    \item IEEE 1800-2017 SystemVerilog Standard
    \item \textit{SystemVerilog for Verification} (3rd Edition) by Chris Spear
    \item \textit{Writing Testbenches using SystemVerilog} by Janick Bergeron
\end{itemize}

% ============================================================================
\vfill
\begin{center}
\rule{0.5\textwidth}{0.4pt}\\
\textit{Document Version: 1.0}\\
\textit{Last Updated: \today}
\end{center}

\end{document}
