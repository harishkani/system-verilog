\documentclass[11pt,a4paper]{article}

% Basic packages only - works on all online compilers
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{multicol}

% Colors
\definecolor{commentgreen}{RGB}{34,139,34}
\definecolor{stringcolor}{RGB}{208,76,239}
\definecolor{keywordcolor}{RGB}{0,0,255}
\definecolor{backgroundcolor}{RGB}{248,248,248}
\definecolor{numbercolor}{RGB}{128,128,128}
\definecolor{exercisecolor}{RGB}{255,250,205}
\definecolor{solutioncolor}{RGB}{230,255,230}
\definecolor{warningcolor}{RGB}{255,230,230}
\definecolor{tipcolor}{RGB}{230,240,255}
\definecolor{quizcolor}{RGB}{255,240,245}

% SystemVerilog language definition
\lstdefinelanguage{SystemVerilog}{
  alsoletter={@,\$},
  morekeywords={
    module, endmodule, input, output, inout, wire, reg, logic, bit,
    always, always_ff, always_comb, always_latch, initial, begin, end,
    if, else, case, endcase, for, while, repeat, forever, do,
    function, endfunction, task, endtask, return, automatic, static,
    class, endclass, new, extends, virtual, pure, extern, this, super,
    typedef, struct, packed, enum, union, interface, endinterface, modport,
    fork, join, join_any, join_none, disable, wait, wait_order,
    rand, randc, constraint, randomize, covergroup, endgroup, coverpoint,
    bins, import, export, ref, const, local, protected, string, int, byte,
    real, void, assert, assume, cover, property, sequence, expect,
    clocking, endclocking, program, endprogram, package, endpackage,
    timeunit, timeprecision, unique, priority, final,
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\lstset{
  language=SystemVerilog,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{keywordcolor}\bfseries,
  commentstyle=\color{commentgreen}\itshape,
  stringstyle=\color{stringcolor},
  numberstyle=\tiny\color{numbercolor},
  backgroundcolor=\color{backgroundcolor},
  frame=single,
  rulecolor=\color{black!30},
  numbers=left,
  numbersep=8pt,
  tabsize=4,
  breaklines=true,
  breakatwhitespace=false,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=15pt,
  xrightmargin=5pt,
  aboveskip=10pt,
  belowskip=10pt,
  keepspaces=true,
  columns=flexible
}

% Simple colored boxes without tcolorbox
\newenvironment{coloredbox}[2]{%
  \par\medskip\noindent
  \begin{minipage}{\linewidth}
  \setlength{\fboxsep}{10pt}%
  \fcolorbox{#1!75!black}{#1}{%
  \begin{minipage}{0.95\linewidth}%
  \textbf{#2}\\[5pt]%
}{%
  \end{minipage}}%
  \end{minipage}%
  \medskip\par
}

\newenvironment{exercisebox}{\begin{coloredbox}{exercisecolor}{Exercise}}{\end{coloredbox}}
\newenvironment{solutionbox}{\begin{coloredbox}{solutioncolor}{Solution}}{\end{coloredbox}}
\newenvironment{warningbox}{\begin{coloredbox}{warningcolor}{Warning}}{\end{coloredbox}}
\newenvironment{tipbox}{\begin{coloredbox}{tipcolor}{Tip}}{\end{coloredbox}}
\newenvironment{quizbox}{\begin{coloredbox}{quizcolor}{Quiz}}{\end{coloredbox}}

% Hyperref setup
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
  pdftitle={SystemVerilog Functions and Tasks: Complete Learning Guide},
  pdfauthor={},
  pdfsubject={SystemVerilog Programming},
  pdfkeywords={SystemVerilog, Functions, Tasks, HDL, Verification},
  bookmarksnumbered=true,
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{SystemVerilog Functions \& Tasks - Complete Guide}
\fancyhead[R]{\thepage}
\fancyfoot[C]{From Beginner to Expert}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Title formatting
\titleformat{\section}
  {\normalfont\Large\bfseries\color{blue!70!black}}
  {\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{blue!50!black}}
  {\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries\color{blue!30!black}}
  {\thesubsubsection}{1em}{}

% Title
\title{
  \vspace{-2cm}
  \Huge\textbf{SystemVerilog Functions and Tasks} \\
  \LARGE Complete Learning Guide \\
  \Large From Beginner to Expert \\
  \vspace{0.5cm}
  \large With Exercises, Real-World Examples, and Visual Aids
}
\author{}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This comprehensive guide is designed to take you from a complete beginner to an expert in SystemVerilog functions and tasks. Unlike typical reference materials, this guide includes:
\begin{itemize}
  \item Progressive learning from basic to advanced concepts
  \item 50+ hands-on exercises with detailed solutions
  \item Real-world examples including complete testbenches and protocol drivers
  \item Visual aids: timing diagrams, memory layouts, and flowcharts
  \item Self-assessment quizzes after each major section
  \item Troubleshooting guide with common errors and solutions
  \item Quick reference cheat sheet
  \item Performance optimization techniques
\end{itemize}
This is a complete learning resource suitable for self-study, classroom instruction, or as a professional reference.
\end{abstract}

\tableofcontents
\newpage

% ============================================================================
\section{How to Use This Guide}

\subsection{Learning Path}

This guide is structured for progressive learning:

\begin{enumerate}
  \item \textbf{Read the Theory}: Each section starts with clear explanations
  \item \textbf{Study the Examples}: Working code demonstrates each concept
  \item \textbf{Complete the Exercises}: Hands-on practice solidifies understanding
  \item \textbf{Check Your Solutions}: Detailed solutions with explanations
  \item \textbf{Take the Quiz}: Self-assessment to verify comprehension
  \item \textbf{Review Visual Aids}: Diagrams reinforce concepts
\end{enumerate}

\subsection{Recommended Study Plan}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Level} & \textbf{Time Required} & \textbf{Focus Areas} \\
\hline
Beginner & 4-6 hours & Sections 2-4, Exercises 1-10 \\
Intermediate & 6-8 hours & Sections 5-7, Exercises 11-30 \\
Advanced & 8-10 hours & Sections 8-11, Exercises 31-50 \\
Complete Mastery & 20+ hours & All sections, all exercises, projects \\
\hline
\end{tabular}
\caption{Recommended Study Plan}
\end{table}

\subsection{Prerequisites}

\begin{itemize}
  \item Basic understanding of digital logic
  \item Familiarity with Verilog or any HDL (helpful but not required)
  \item Access to a SystemVerilog simulator (ModelSim, VCS, Xcelium, or open-source alternatives like Verilator)
\end{itemize}

% ============================================================================
\section{Introduction}

\subsection{What Are Functions and Tasks?}

Functions and tasks are fundamental building blocks in SystemVerilog that enable:
\begin{itemize}
  \item \textbf{Code Reusability}: Write once, use many times
  \item \textbf{Modularity}: Break complex operations into manageable pieces
  \item \textbf{Abstraction}: Hide implementation details
  \item \textbf{Maintainability}: Easier to debug and update
\end{itemize}

\subsection{Key Differences: Functions vs Tasks}

\begin{table}[H]
\centering
\begin{tabular}{|>{\raggedright}p{3.5cm}|>{\raggedright}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
\textbf{Feature} & \textbf{Functions} & \textbf{Tasks} \\
\hline
Return Value & Must return a value & Cannot return a value (use output/inout) \\
\hline
Timing Control & No delays allowed & Can contain delays (\#, @, wait) \\
\hline
Execution Time & Zero simulation time & Can consume simulation time \\
\hline
Task/Function Calls & Can call functions only & Can call both tasks and functions \\
\hline
Output Arguments & Single return value (SV allows output/ref) & Multiple outputs via output/inout \\
\hline
Usage in Expressions & Can be used in expressions & Cannot be used in expressions \\
\hline
\end{tabular}
\caption{Functions vs Tasks Comparison}
\end{table}

\subsection{Visual Comparison}

\textbf{Function vs Task Execution Model:}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{FUNCTION} & \textbf{TASK} \\
\hline
Input: a, b & Input: a, b \\
Computation & Wait/Delay \\
(Zero time) & Computation \\
Return: result & Output: c, d \\
$\Delta t = 0$ & $\Delta t > 0$ \\
\hline
\end{tabular}
\end{center}

\begin{tipbox}
\textbf{Quick Decision Guide:}
\begin{itemize}
  \item Need to return a value and use in expression? $\rightarrow$ Use Function
  \item Need timing control or delays? $\rightarrow$ Use Task
  \item Pure computation without side effects? $\rightarrow$ Use Function
  \item Multiple outputs needed? $\rightarrow$ Use Task or Function with output/ref
\end{itemize}
\end{tipbox}

% ============================================================================
\section{Beginner Level - Functions}

\subsection{Your First Function}

Let's start with the simplest possible function:

\begin{lstlisting}[caption={The Simplest Function}]
function int add(int a, int b);
    return a + b;
endfunction
\end{lstlisting}

\textbf{Breaking it down:}
\begin{itemize}
  \item \texttt{function} - Keyword to declare a function
  \item \texttt{int} - Return type (32-bit signed integer)
  \item \texttt{add} - Function name
  \item \texttt{(int a, int b)} - Parameters: two integers
  \item \texttt{return a + b} - Returns the sum
  \item \texttt{endfunction} - Marks the end
\end{itemize}

\subsection{Using Functions}

\begin{lstlisting}[caption={Using the add Function}]
module test_add;
    int result;

    initial begin
        result = add(5, 3);
        $display("5 + 3 = %0d", result);  // Output: 5 + 3 = 8

        // Functions can be used directly in expressions
        $display("10 + 20 = %0d", add(10, 20));  // Output: 10 + 20 = 30

        // Functions can be nested
        $display("Nested: %0d", add(add(1, 2), add(3, 4)));  // Output: Nested: 10
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 1: Create a subtract function}

Write a function called \texttt{subtract} that takes two integers and returns their difference.
Test it with values: 10 - 3, 100 - 50, 7 - 12.
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 2: Create a multiply function}

Write a function called \texttt{multiply} that takes two integers and returns their product.
Test it with values: 6 $\times$ 7, 12 $\times$ 12, -5 $\times$ 3.
\end{exercisebox}

\subsection{Function Return Types}

Functions can return various data types:

\begin{lstlisting}[caption={Different Return Types}]
// Bit function - returns single bit
function bit is_even(int n);
    return (n % 2 == 0);
endfunction

// Logic function - returns 4-state logic
function logic [7:0] get_lower_byte(logic [15:0] data);
    return data[7:0];
endfunction

// Real function - returns floating point
function real celsius_to_fahrenheit(real celsius);
    return (celsius * 9.0/5.0) + 32.0;
endfunction

// String function - returns string
function string get_grade(int score);
    if (score >= 90) return "A";
    if (score >= 80) return "B";
    if (score >= 70) return "C";
    if (score >= 60) return "D";
    return "F";
endfunction

module test_return_types;
    initial begin
        $display("Is 4 even? %0d", is_even(4));       // Output: 1
        $display("Is 7 even? %0d", is_even(7));       // Output: 0
        $display("Lower byte of 16'hABCD: %h", get_lower_byte(16'hABCD));  // CD
        $display("100C = %0f F", celsius_to_fahrenheit(100.0));  // 212.000000
        $display("Score 85 = %s", get_grade(85));     // B
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 3: Temperature conversion}

Write two functions:
\begin{enumerate}
  \item \texttt{fahrenheit\_to\_celsius(real f)} - converts F to C
  \item \texttt{celsius\_to\_kelvin(real c)} - converts C to Kelvin
\end{enumerate}
Formula: C = (F - 32) $\times$ 5/9, K = C + 273.15

Test with: 32$^\circ$F, 98.6$^\circ$F, 212$^\circ$F
\end{exercisebox}

\subsection{Void Functions}

Functions that don't need to return a value can use \texttt{void}:

\begin{lstlisting}[caption={Void Functions}]
function void print_banner(string msg);
    $display("==================================");
    $display("  %s", msg);
    $display("==================================");
endfunction

function void print_bits(bit [7:0] data);
    for (int i = 7; i >= 0; i--)
        $write("%0d", data[i]);
    $display("");
endfunction

module test_void;
    initial begin
        print_banner("SIMULATION START");
        print_bits(8'b10110010);  // Output: 10110010
        print_banner("SIMULATION END");
    end
endmodule
\end{lstlisting}

\subsection{Automatic Functions (For Recursion)}

The \texttt{automatic} keyword creates new storage for each function call:

\begin{lstlisting}[caption={Recursive Factorial Function}]
function automatic int factorial(int n);
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
endfunction

module test_factorial;
    initial begin
        for (int i = 0; i <= 10; i++)
            $display("%0d! = %0d", i, factorial(i));
    end
endmodule
\end{lstlisting}

\textbf{How factorial(5) works - Call Stack:}

\begin{verbatim}
factorial(5) → n=5, returns 5 * factorial(4) = 120
  factorial(4) → n=4, returns 4 * factorial(3) = 24
    factorial(3) → n=3, returns 3 * factorial(2) = 6
      factorial(2) → n=2, returns 2 * factorial(1) = 2
        factorial(1) → n=1, returns 1
\end{verbatim}

\begin{warningbox}
\textbf{Always use \texttt{automatic} for recursive functions!}

Without \texttt{automatic}, variables are shared between recursive calls, leading to incorrect results.
\end{warningbox}

\begin{exercisebox}
\textbf{Exercise 4: Fibonacci sequence}

Write a recursive function \texttt{fibonacci(int n)} that returns the nth Fibonacci number.
Formula: fib(0)=0, fib(1)=1, fib(n)=fib(n-1)+fib(n-2)

Test with: n=0 through n=15
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 5: Power function}

Write a recursive function \texttt{power(int base, int exp)} that calculates base$^{exp}$.

Test with: 2$^{10}$, 3$^{5}$, 5$^{3}$
\end{exercisebox}

\subsection{Quiz: Beginner Functions}

\begin{quizbox}
\textbf{Quiz 1: Functions Basics}

\begin{enumerate}
  \item What keyword marks the beginning of a function? \_\_\_\_\_\_\_\_\_\_
  \item Can a function execute without returning a value? (Yes/No) \_\_\_\_\_\_
  \item What return type should you use if a function doesn't return a meaningful value? \_\_\_\_\_\_\_\_\_\_
  \item When is the \texttt{automatic} keyword required? \_\_\_\_\_\_\_\_\_\_
  \item Can functions contain timing controls like \#10? (Yes/No) \_\_\_\_\_\_
  \item Write the signature for a function named \texttt{max} that takes two integers and returns the larger one:

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{function}
  \item No (it must return a value, or use \texttt{void})
  \item \texttt{void}
  \item For recursive functions or when concurrent calls need separate storage
  \item No
  \item \texttt{function int max(int a, int b);}
\end{enumerate}
\end{quizbox}

% ============================================================================
\section{Beginner Level - Tasks}

\subsection{Your First Task}

Tasks are similar to functions but can contain timing controls and don't directly return values:

\begin{lstlisting}[caption={Simple Task}]
task display_message(input string msg);
    $display("[%0t] %s", $time, msg);
endtask

module test_task;
    initial begin
        display_message("Simulation started");
        #10;
        display_message("After 10 time units");
    end
endmodule
\end{lstlisting}

\subsection{Tasks with Output Parameters}

Tasks return values through \texttt{output} or \texttt{inout} parameters:

\begin{lstlisting}[caption={Task with Outputs}]
task add_and_multiply(
    input int a,
    input int b,
    output int sum,
    output int product
);
    sum = a + b;
    product = a * b;
endtask

module test_outputs;
    int s, p;

    initial begin
        add_and_multiply(5, 3, s, p);
        $display("5 + 3 = %0d, 5 * 3 = %0d", s, p);
    end
endmodule
\end{lstlisting}

\subsection{Tasks with Timing}

The key advantage of tasks: they can contain delays!

\begin{lstlisting}[caption={Task with Timing Control}]
task wait_and_print(input int delay_time, input string msg);
    $display("[%0t] Waiting %0d time units...", $time, delay_time);
    #delay_time;
    $display("[%0t] %s", $time, msg);
endtask

module test_timing;
    initial begin
        $display("[%0t] Start", $time);
        wait_and_print(10, "First message");
        wait_and_print(20, "Second message");
        $display("[%0t] Done", $time);
    end
endmodule
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
[0] Start
[0] Waiting 10 time units...
[10] First message
[10] Waiting 20 time units...
[30] Second message
[30] Done
\end{verbatim}

\subsection{Timing Diagram}

\textbf{Task Timing Execution:}

\begin{verbatim}
Time:    0      10                    30
         |------|---------------------|
Events:  Start  Message 1             Message 2
         [wait 10]    [wait 20]
\end{verbatim}

\begin{exercisebox}
\textbf{Exercise 6: Clock generator task}

Write a task \texttt{generate\_clocks(output bit clk, input int num\_cycles)} that generates \texttt{num\_cycles} clock pulses with a period of 10 time units (5 high, 5 low).
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 7: Bus write task}

Write a task \texttt{bus\_write(input bit [7:0] addr, input bit [31:0] data)} that:
\begin{enumerate}
  \item Displays "Writing to address..."
  \item Waits 5 time units
  \item Displays "Write complete"
\end{enumerate}
\end{exercisebox}

\subsection{Automatic Tasks (Reentrant)}

Like functions, tasks can be automatic for concurrent execution:

\begin{lstlisting}[caption={Automatic Task for Parallel Execution}]
task automatic delayed_print(input int id, input int delay);
    #delay;
    $display("[%0t] Task %0d completed", $time, id);
endtask

module test_parallel;
    initial begin
        fork
            delayed_print(1, 10);
            delayed_print(2, 5);
            delayed_print(3, 15);
        join
        $display("[%0t] All tasks done", $time);
    end
endmodule
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
[5] Task 2 completed
[10] Task 1 completed
[15] Task 3 completed
[15] All tasks done
\end{verbatim}

\textbf{Parallel Task Execution Timeline:}

\begin{verbatim}
Time:  0    5    10   15
Task1: |----------|
Task2: |-----|
Task3: |--------------|
\end{verbatim}

\begin{exercisebox}
\textbf{Exercise 8: Traffic light controller}

Write an automatic task \texttt{traffic\_light(input string light\_name, input int green\_time, input int yellow\_time, input int red\_time)} that simulates a traffic light cycle.
\end{exercisebox}

\subsection{Quiz: Beginner Tasks}

\begin{quizbox}
\textbf{Quiz 2: Tasks Basics}

\begin{enumerate}
  \item Can tasks return values directly like functions? (Yes/No) \_\_\_\_\_\_
  \item How do tasks return multiple values? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can tasks contain \#delay statements? (Yes/No) \_\_\_\_\_\_
  \item What keyword makes a task reentrant? \_\_\_\_\_\_\_\_\_\_
  \item Can you use a task directly in an expression like \texttt{x = my\_task()}? (Yes/No) \_\_\_\_\_\_
  \item What construct allows multiple tasks to run concurrently? \_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item No
  \item Through \texttt{output} or \texttt{inout} parameters
  \item Yes
  \item \texttt{automatic}
  \item No
  \item \texttt{fork-join}
\end{enumerate}
\end{quizbox}

% ============================================================================
\section{Intermediate Level - Advanced Function Features}

\subsection{Default Arguments}

Functions can have default parameter values:

\begin{lstlisting}[caption={Functions with Default Arguments}]
function int power(int base, int exp = 2);
    int result = 1;
    for (int i = 0; i < exp; i++)
        result *= base;
    return result;
endfunction

module test_defaults;
    initial begin
        $display("3^2 = %0d", power(3));        // Uses default exp=2
        $display("2^8 = %0d", power(2, 8));     // Overrides default
        $display("5^3 = %0d", power(5, 3));     // Overrides default
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 9: Enhanced print function}

Write a function \texttt{format\_number(int num, int width=8, bit zero\_pad=0)} that:
\begin{itemize}
  \item Formats \texttt{num} to \texttt{width} characters
  \item If \texttt{zero\_pad} is 1, pad with zeros; otherwise pad with spaces
  \item Returns a formatted string
\end{itemize}
\end{exercisebox}

\subsection{Output and Ref Arguments}

Functions can have \texttt{output} and \texttt{ref} parameters:

\begin{lstlisting}[caption={Function with Output Arguments}]
function int divide_with_remainder(
    int dividend,
    int divisor,
    output int remainder
);
    if (divisor == 0) begin
        remainder = 0;
        return 0;
    end
    remainder = dividend % divisor;
    return dividend / divisor;
endfunction

module test_divide;
    int quotient, remainder;

    initial begin
        quotient = divide_with_remainder(17, 5, remainder);
        $display("17 / 5 = %0d remainder %0d", quotient, remainder);
    end
endmodule
\end{lstlisting}

\subsubsection{Reference Parameters (ref)}

\texttt{ref} enables pass-by-reference, avoiding copies of large data:

\begin{lstlisting}[caption={Using ref for Pass-by-Reference}]
function void swap(ref int a, ref int b);
    int temp = a;
    a = b;
    b = temp;
endfunction

function void sort_two(ref int a, ref int b);
    if (a > b)
        swap(a, b);
endfunction

module test_ref;
    int x = 10, y = 20;

    initial begin
        $display("Before swap: x=%0d, y=%0d", x, y);
        swap(x, y);
        $display("After swap: x=%0d, y=%0d", x, y);

        x = 50; y = 30;
        $display("Before sort: x=%0d, y=%0d", x, y);
        sort_two(x, y);
        $display("After sort: x=%0d, y=%0d", x, y);
    end
endmodule
\end{lstlisting}

\begin{tipbox}
\textbf{When to use ref:}
\begin{itemize}
  \item Large data structures (arrays, structs)
  \item Need to modify the original variable
  \item Performance-critical code (avoids copying)
\end{itemize}

\textbf{When NOT to use ref:}
\begin{itemize}
  \item Small data types (int, bit, etc.) - overhead not worth it
  \item When you want to protect the original from modification
\end{itemize}
\end{tipbox}

\begin{exercisebox}
\textbf{Exercise 10: Array manipulation}

Write a function \texttt{reverse\_array(ref int arr[])} that reverses an integer array in-place using \texttt{ref}.

Test with: \{1, 2, 3, 4, 5\}
\end{exercisebox}

\subsection{Automatic vs Static Storage}

Understanding storage lifetime is crucial:

\begin{lstlisting}[caption={Static vs Automatic Storage Comparison}]
module storage_comparison;

    // Static function (default) - variables persist
    function int counter_static();
        static int count = 0;  // Initialized once
        count++;
        return count;
    endfunction

    // Automatic function - variables recreated each call
    function automatic int counter_auto();
        int count = 0;  // Initialized every call
        count++;
        return count;
    endfunction

    initial begin
        $display("=== Static Function ===");
        repeat(5)
            $display("Count: %0d", counter_static());
        // Output: 1, 2, 3, 4, 5

        $display("\n=== Automatic Function ===");
        repeat(5)
            $display("Count: %0d", counter_auto());
        // Output: 1, 1, 1, 1, 1
    end
endmodule
\end{lstlisting}

\textbf{Static vs Automatic Storage:}

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Static Storage} & \textbf{Automatic Storage} \\
\hline
Single instance & New instance each call \\
count = 5 (final) & count = 1 (always) \\
Shared across calls & Independent per call \\
\hline
\end{tabular}
\end{center}

\begin{exercisebox}
\textbf{Exercise 11: Debug message counter}

Write a static function \texttt{debug\_msg(string msg)} that:
\begin{itemize}
  \item Keeps track of how many debug messages have been printed
  \item Prints: "[Debug \#N] message"
  \item Returns the count
\end{itemize}
\end{exercisebox}

\subsection{Class Methods}

Functions and tasks can be class members:

\begin{lstlisting}[caption={Class Methods Example}]
class BankAccount;
    local real balance;  // Private member

    function new(real initial_balance = 0);
        balance = initial_balance;
    endfunction

    function void deposit(real amount);
        if (amount > 0) begin
            balance += amount;
            $display("Deposited $%0.2f, Balance: $%0.2f", amount, balance);
        end else begin
            $display("Error: Invalid deposit amount");
        end
    endfunction

    function bit withdraw(real amount);
        if (amount > balance) begin
            $display("Error: Insufficient funds");
            return 0;
        end else if (amount <= 0) begin
            $display("Error: Invalid withdrawal amount");
            return 0;
        end else begin
            balance -= amount;
            $display("Withdrew $%0.2f, Balance: $%0.2f", amount, balance);
            return 1;
        end
    endfunction

    function real get_balance();
        return balance;
    endfunction
endclass

module test_bank_account;
    BankAccount acc;

    initial begin
        acc = new(1000.0);
        acc.deposit(500.0);
        acc.withdraw(200.0);
        acc.withdraw(2000.0);  // Should fail
        $display("Final balance: $%0.2f", acc.get_balance());
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 12: Stack class}

Implement a \texttt{Stack} class with:
\begin{itemize}
  \item \texttt{function void push(int value)} - add to stack
  \item \texttt{function int pop()} - remove and return top
  \item \texttt{function bit is\_empty()} - check if empty
  \item \texttt{function int peek()} - return top without removing
  \item \texttt{function int size()} - return number of elements
\end{itemize}
Test with push: 10, 20, 30, then pop twice.
\end{exercisebox}

\subsection{Functions Returning Complex Types}

Functions can return arrays, structures, and objects:

\begin{lstlisting}[caption={Returning Complex Types}]
// Define structures
typedef struct {
    int x;
    int y;
} point_t;

typedef struct {
    point_t top_left;
    point_t bottom_right;
} rectangle_t;

// Function returning structure
function point_t create_point(int x, int y);
    point_t p;
    p.x = x;
    p.y = y;
    return p;
endfunction

// Function returning dynamic array
function int[] generate_sequence(int start, int count);
    int result[];
    result = new[count];
    for (int i = 0; i < count; i++)
        result[i] = start + i;
    return result;
endfunction

// Function returning structure with nested structures
function rectangle_t create_rectangle(int x1, int y1, int x2, int y2);
    rectangle_t rect;
    rect.top_left = create_point(x1, y1);
    rect.bottom_right = create_point(x2, y2);
    return rect;
endfunction

module test_complex_returns;
    point_t p;
    int seq[];
    rectangle_t rect;

    initial begin
        p = create_point(10, 20);
        $display("Point: (%0d, %0d)", p.x, p.y);

        seq = generate_sequence(5, 10);
        $display("Sequence: %p", seq);

        rect = create_rectangle(0, 0, 100, 50);
        $display("Rectangle: (%0d,%0d) to (%0d,%0d)",
                 rect.top_left.x, rect.top_left.y,
                 rect.bottom_right.x, rect.bottom_right.y);
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 13: Matrix operations}

Define a structure for a 2x2 matrix:
\begin{lstlisting}
typedef struct {
    int data[2][2];
} matrix_t;
\end{lstlisting}

Write functions:
\begin{itemize}
  \item \texttt{create\_matrix(int a, b, c, d)} - creates [[a,b],[c,d]]
  \item \texttt{add\_matrices(matrix\_t m1, m2)} - returns m1+m2
  \item \texttt{print\_matrix(matrix\_t m)} - displays the matrix
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Intermediate Functions}

\begin{quizbox}
\textbf{Quiz 3: Advanced Function Features}

\begin{enumerate}
  \item What keyword enables pass-by-reference? \_\_\_\_\_\_\_\_\_\_
  \item Do default arguments go at the beginning or end of the parameter list? \_\_\_\_\_\_\_\_\_\_
  \item What's the difference between \texttt{output} and \texttt{ref}?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item When should you use \texttt{static} variables in functions?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can functions return class objects? (Yes/No) \_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{ref}
  \item End (all required parameters come first)
  \item \texttt{output} passes value back after function; \texttt{ref} passes reference (can read and modify original)
  \item When you need to preserve state between function calls
  \item Yes
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Real-World Example 1: Complete UART Transmitter}

Let's build a complete, realistic UART transmitter using tasks and functions:

\begin{lstlisting}[caption={UART Transmitter - Complete Example}, basicstyle=\ttfamily\footnotesize]
module uart_transmitter #(
    parameter CLK_FREQ = 50_000_000,  // 50 MHz
    parameter BAUD_RATE = 115200
)(
    input  logic clk,
    input  logic rst_n,
    output logic tx
);
    localparam int CLKS_PER_BIT = CLK_FREQ / BAUD_RATE;

    typedef enum logic [2:0] {
        IDLE, START, DATA, PARITY, STOP
    } state_t;

    state_t state;
    logic [7:0] data_reg;
    int bit_index;
    int clk_count;
    logic parity_bit;

    // Function: Calculate even parity
    function bit calc_parity(bit [7:0] data);
        return ^data;  // XOR reduction
    endfunction

    // Task: Transmit one byte
    task automatic transmit_byte(input logic [7:0] data);
        @(posedge clk);
        while (state != IDLE) @(posedge clk);  // Wait if busy

        data_reg <= data;
        parity_bit <= calc_parity(data);
        state <= START;
    endtask

    // Main state machine
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            clk_count <= 0;
            bit_index <= 0;
        end else begin
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    clk_count <= 0;
                    bit_index <= 0;
                end

                START: begin
                    tx <= 1'b0;  // Start bit
                    if (clk_count < CLKS_PER_BIT - 1) begin
                        clk_count <= clk_count + 1;
                    end else begin
                        clk_count <= 0;
                        state <= DATA;
                    end
                end

                DATA: begin
                    tx <= data_reg[bit_index];
                    if (clk_count < CLKS_PER_BIT - 1) begin
                        clk_count <= clk_count + 1;
                    end else begin
                        clk_count <= 0;
                        if (bit_index < 7) begin
                            bit_index <= bit_index + 1;
                        end else begin
                            bit_index <= 0;
                            state <= PARITY;
                        end
                    end
                end

                PARITY: begin
                    tx <= parity_bit;
                    if (clk_count < CLKS_PER_BIT - 1) begin
                        clk_count <= clk_count + 1;
                    end else begin
                        clk_count <= 0;
                        state <= STOP;
                    end
                end

                STOP: begin
                    tx <= 1'b1;  // Stop bit
                    if (clk_count < CLKS_PER_BIT - 1) begin
                        clk_count <= clk_count + 1;
                    end else begin
                        clk_count <= 0;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule

// Testbench
module uart_tb;
    logic clk, rst_n, tx;

    uart_transmitter #(
        .CLK_FREQ(1_000_000),  // 1 MHz for simulation
        .BAUD_RATE(9600)
    ) dut (.*);

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 100ns period = 1MHz
    end

    // Task: Send string over UART
    task automatic send_string(input string str);
        for (int i = 0; i < str.len(); i++) begin
            dut.transmit_byte(str[i]);
            wait(dut.state == dut.IDLE);
        end
    endtask

    // Task: Monitor UART output
    task automatic monitor_uart();
        forever begin
            @(negedge tx);  // Detect start bit
            $display("[%0t] Start bit detected", $time);
            // Add monitoring logic here
        end
    endtask

    initial begin
        rst_n = 0;
        repeat(5) @(posedge clk);
        rst_n = 1;

        fork
            monitor_uart();
        join_none

        send_string("Hello");

        #100000;
        $finish;
    end
endmodule
\end{lstlisting}

\textbf{UART Serial Frame Format:}

\begin{verbatim}
    ____      _____________________________      _____
   |    |    |                             |    |
1  |    |____|  D0 D1 D2 D3 D4 D5 D6 D7   |____|  P  |____
0  |    |    |                             |    |    |
   Start     Data Bits (8)                Parity Stop
\end{verbatim}

\begin{exercisebox}
\textbf{Exercise 14: UART Receiver}

Implement a UART receiver module with:
\begin{itemize}
  \item Function to verify parity
  \item Task to receive one byte
  \item State machine for RX
\end{itemize}
\end{exercisebox}

\subsection{Key Takeaways from UART Example}

\begin{itemize}
  \item \textbf{Functions} for pure calculations (parity)
  \item \textbf{Tasks} for sequential operations with timing (transmit\_byte)
  \item \textbf{Automatic tasks} for concurrent operations
  \item Combination creates clean, maintainable code
\end{itemize}

\newpage
% ============================================================================
\section{Real-World Example 2: AXI4-Lite Master Driver}

Let's implement a realistic AXI4-Lite bus driver:

\begin{lstlisting}[caption={AXI4-Lite Master Driver}, basicstyle=\ttfamily\footnotesize]
class AXI4Lite_Master;
    virtual axi4lite_if vif;

    function new(virtual axi4lite_if vif);
        this.vif = vif;
    endfunction

    // Task: Write to AXI4-Lite bus
    task automatic write(
        input  bit [31:0] addr,
        input  bit [31:0] data,
        input  bit [3:0]  strb = 4'hF,  // Default: all bytes
        output bit [1:0]  resp
    );
        // Address Write Channel
        @(posedge vif.clk);
        vif.awvalid <= 1'b1;
        vif.awaddr  <= addr;
        vif.awprot  <= 3'b000;

        // Wait for address ready
        do @(posedge vif.clk);
        while (!vif.awready);
        vif.awvalid <= 1'b0;

        // Write Data Channel
        vif.wvalid <= 1'b1;
        vif.wdata  <= data;
        vif.wstrb  <= strb;

        // Wait for data ready
        do @(posedge vif.clk);
        while (!vif.wready);
        vif.wvalid <= 1'b0;

        // Write Response Channel
        vif.bready <= 1'b1;
        do @(posedge vif.clk);
        while (!vif.bvalid);
        resp = vif.bresp;
        vif.bready <= 1'b0;

        $display("[%0t] AXI Write: Addr=0x%h, Data=0x%h, Resp=%0d",
                 $time, addr, data, resp);
    endtask

    // Task: Read from AXI4-Lite bus
    task automatic read(
        input  bit [31:0] addr,
        output bit [31:0] data,
        output bit [1:0]  resp
    );
        // Address Read Channel
        @(posedge vif.clk);
        vif.arvalid <= 1'b1;
        vif.araddr  <= addr;
        vif.arprot  <= 3'b000;

        // Wait for address ready
        do @(posedge vif.clk);
        while (!vif.arready);
        vif.arvalid <= 1'b0;

        // Read Data Channel
        vif.rready <= 1'b1;
        do @(posedge vif.clk);
        while (!vif.rvalid);
        data = vif.rdata;
        resp = vif.rresp;
        vif.rready <= 1'b0;

        $display("[%0t] AXI Read: Addr=0x%h, Data=0x%h, Resp=%0d",
                 $time, addr, data, resp);
    endtask

    // Task: Burst write (multiple sequential writes)
    task automatic burst_write(
        input bit [31:0] start_addr,
        input bit [31:0] data[],
        input int        count
    );
        bit [1:0] resp;

        for (int i = 0; i < count; i++) begin
            write(start_addr + (i*4), data[i], 4'hF, resp);
            if (resp != 2'b00) begin  // OKAY response
                $error("Write failed at address 0x%h with response %0d",
                       start_addr + (i*4), resp);
                return;
            end
        end

        $display("Burst write completed: %0d transactions", count);
    endtask

    // Task: Read-modify-write
    task automatic read_modify_write(
        input  bit [31:0] addr,
        input  bit [31:0] mask,
        input  bit [31:0] value
    );
        bit [31:0] read_data, write_data;
        bit [1:0] resp;

        // Read current value
        read(addr, read_data, resp);
        if (resp != 2'b00) begin
            $error("Read failed in RMW");
            return;
        end

        // Modify
        write_data = (read_data & ~mask) | (value & mask);

        // Write back
        write(addr, write_data, 4'hF, resp);
        if (resp != 2'b00) begin
            $error("Write failed in RMW");
            return;
        end

        $display("RMW: 0x%h: 0x%h -> 0x%h (mask=0x%h, value=0x%h)",
                 addr, read_data, write_data, mask, value);
    endtask

    // Function: Check if response is OKAY
    function bit is_resp_okay(bit [1:0] resp);
        return (resp == 2'b00);
    endfunction

    // Function: Decode response
    function string decode_resp(bit [1:0] resp);
        case (resp)
            2'b00: return "OKAY";
            2'b01: return "EXOKAY";
            2'b10: return "SLVERR";
            2'b11: return "DECERR";
        endcase
    endfunction
endclass

// Interface definition
interface axi4lite_if(input logic clk);
    // Write Address Channel
    logic [31:0] awaddr;
    logic [2:0]  awprot;
    logic        awvalid;
    logic        awready;

    // Write Data Channel
    logic [31:0] wdata;
    logic [3:0]  wstrb;
    logic        wvalid;
    logic        wready;

    // Write Response Channel
    logic [1:0]  bresp;
    logic        bvalid;
    logic        bready;

    // Read Address Channel
    logic [31:0] araddr;
    logic [2:0]  arprot;
    logic        arvalid;
    logic        arready;

    // Read Data Channel
    logic [31:0] rdata;
    logic [1:0]  rresp;
    logic        rvalid;
    logic        rready;
endinterface
\end{lstlisting}

\textbf{AXI4-Lite Write Transaction Timing:}

\begin{verbatim}
CLK       _|‾|_|‾|_|‾|_|‾|_|‾|_|‾|_|‾|_
AWVALID   __|‾‾‾‾‾‾‾|______
AWREADY   ______|‾‾‾|______
WVALID    ______|‾‾‾‾‾‾‾|__
WREADY    __________|‾‾‾|__
BVALID    ______________|‾‾‾‾‾|__
BREADY    ______________|‾‾‾‾‾|__

Phase:    | Addr  | Data  | Resp  |
\end{verbatim}

\begin{exercisebox}
\textbf{Exercise 15: AXI4-Lite Verification}

Add to the AXI4Lite\_Master class:
\begin{itemize}
  \item Task \texttt{verify\_write(addr, data)} - writes then reads back to verify
  \item Function \texttt{calculate\_statistics()} - tracks transaction counts
  \item Task \texttt{stress\_test()} - performs random reads/writes
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 16: APB Protocol Driver}

Implement an APB (Advanced Peripheral Bus) driver class with:
\begin{itemize}
  \item Task \texttt{apb\_write(addr, data)}
  \item Task \texttt{apb\_read(addr, output data)}
  \item Function \texttt{check\_protocol\_compliance()}
\end{itemize}
\end{exercisebox}

\newpage
% ============================================================================
\section{Advanced Level - Virtual Functions and Polymorphism}

\subsection{Understanding Polymorphism}

Polymorphism allows objects of different types to be accessed through the same interface. Virtual functions are the key to polymorphism in SystemVerilog.

\begin{lstlisting}[caption={Polymorphism Example}]
// Base class
class Packet;
    rand bit [7:0] payload[];

    virtual function void pack(ref bit stream[]);
        // Default implementation
        stream = new[payload.size()];
        foreach(payload[i])
            stream[i] = payload[i];
    endfunction

    virtual function void display();
        $display("Generic Packet: %p", payload);
    endfunction
endclass

// Derived class - Ethernet packet
class EthernetPacket extends Packet;
    bit [47:0] dest_mac;
    bit [47:0] src_mac;
    bit [15:0] ethertype;

    virtual function void pack(ref bit stream[]);
        int idx = 0;
        stream = new[14 + payload.size()];  // Header + payload

        // Pack dest MAC
        for (int i = 0; i < 6; i++)
            stream[idx++] = dest_mac[47-i*8 -: 8];

        // Pack src MAC
        for (int i = 0; i < 6; i++)
            stream[idx++] = src_mac[47-i*8 -: 8];

        // Pack ethertype
        stream[idx++] = ethertype[15:8];
        stream[idx++] = ethertype[7:0];

        // Pack payload
        foreach(payload[i])
            stream[idx++] = payload[i];
    endfunction

    virtual function void display();
        $display("Ethernet Packet:");
        $display("  Dest MAC: %h", dest_mac);
        $display("  Src MAC: %h", src_mac);
        $display("  EtherType: %h", ethertype);
        $display("  Payload: %p", payload);
    endfunction
endclass

// Test polymorphism
module test_polymorphism;
    Packet packets[];
    Packet p;
    EthernetPacket ep;
    bit stream[];

    initial begin
        packets = new[2];

        // Create generic packet
        p = new();
        p.payload = '{1, 2, 3, 4};
        packets[0] = p;

        // Create Ethernet packet
        ep = new();
        ep.dest_mac = 48'hFF_FF_FF_FF_FF_FF;
        ep.src_mac = 48'h00_11_22_33_44_55;
        ep.ethertype = 16'h0800;
        ep.payload = '{5, 6, 7, 8};
        packets[1] = ep;

        // Polymorphic calls
        foreach(packets[i]) begin
            packets[i].display();  // Calls appropriate display()
            packets[i].pack(stream);
            $display("Packed stream: %p\n", stream);
        end
    end
endmodule
\end{lstlisting}

\textbf{Class Hierarchy:}

\begin{verbatim}
        +------------------+
        |     Packet       |
        | + payload[]      |
        | + virtual pack() |
        | + virtual display() |
        +------------------+
                 ^
                 |
     +-----------+-----------+
     |                       |
+----------------+    +---------------+
|EthernetPacket  |    |   IPPacket    |
|+ dest_mac      |    | + src_ip      |
|+ src_mac       |    | + dest_ip     |
|+ ethertype     |    | + protocol    |
+----------------+    +---------------+
\end{verbatim}

\begin{exercisebox}
\textbf{Exercise 17: Protocol packet hierarchy}

Create a class hierarchy:
\begin{itemize}
  \item Base class \texttt{NetworkPacket} with virtual \texttt{get\_header\_size()}
  \item Derived \texttt{IPv4Packet} (20 byte header)
  \item Derived \texttt{IPv6Packet} (40 byte header)
  \item Derived \texttt{TCPPacket extends IPv4Packet} (adds 20 byte TCP header)
\end{itemize}
Test polymorphism with an array of mixed packet types.
\end{exercisebox}

\subsection{Pure Virtual Functions (Abstract Classes)}

Pure virtual functions define abstract base classes that cannot be instantiated directly.

\begin{lstlisting}[caption={Abstract Classes with Pure Virtual Functions}]
// Abstract base class
virtual class AbstractProcessor;
    // Pure virtual function (must be overridden)
    pure virtual function void process(int data);

    // Concrete function
    function void log_operation(string msg);
        $display("[LOG] %s", msg);
    endfunction
endclass

// Concrete implementation
class DataProcessor extends AbstractProcessor;
    virtual function void process(int data);
        log_operation($sformatf("Processing data: %0d", data));
        // Processing logic here
    endfunction
endclass

module abstract_class_example;
    DataProcessor proc;

    initial begin
        proc = new();
        proc.process(42);
        // Output: [LOG] Processing data: 42
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 18: Abstract driver class}

Create an abstract \texttt{BusDriver} class with:
\begin{itemize}
  \item Pure virtual function \texttt{read(addr, output data)}
  \item Pure virtual function \texttt{write(addr, data)}
  \item Concrete function \texttt{verify\_transaction()}
\end{itemize}
Then create \texttt{AHBDriver} and \texttt{APBDriver} implementations.
\end{exercisebox}

\subsection{Function Chaining and Fluent Interfaces}

Function chaining enables a fluent API style:

\begin{lstlisting}[caption={Fluent Interface Pattern}]
class FluentBuilder;
    int value;
    string name;

    function new();
        value = 0;
        name = "";
    endfunction

    // Functions return 'this' for chaining
    function FluentBuilder set_value(int v);
        value = v;
        return this;
    endfunction

    function FluentBuilder set_name(string n);
        name = n;
        return this;
    endfunction

    function void display();
        $display("Name: %s, Value: %0d", name, value);
    endfunction
endclass

module fluent_interface_example;
    FluentBuilder builder;

    initial begin
        builder = new();

        // Method chaining
        builder.set_name("MyObject")
               .set_value(100)
               .display();
        // Output: Name: MyObject, Value: 100
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 19: Fluent test builder}

Create a \texttt{TestConfig} class with fluent interface for:
\begin{itemize}
  \item \texttt{set\_timeout(int t)}
  \item \texttt{set\_verbosity(int v)}
  \item \texttt{enable\_coverage()}
  \item \texttt{build()} - returns configured object
\end{itemize}
\end{exercisebox}

\newpage
% ============================================================================
\section{Advanced Topics}

\subsection{Parameterized Functions and Tasks}

Functions and tasks can use module parameters:

\begin{lstlisting}[caption={Parameterized Functions}]
module parameterized_example #(parameter WIDTH = 8);

    // Function using module parameter
    function bit [WIDTH-1:0] reverse_bits(bit [WIDTH-1:0] data);
        bit [WIDTH-1:0] result;
        for (int i = 0; i < WIDTH; i++)
            result[i] = data[WIDTH-1-i];
        return result;
    endfunction

    initial begin
        bit [WIDTH-1:0] data = 8'b10110010;
        bit [WIDTH-1:0] reversed;

        reversed = reverse_bits(data);
        $display("Original:  %b", data);
        $display("Reversed:  %b", reversed);
    end
endmodule
\end{lstlisting}

\subsection{Tasks with Fork-Join for Parallelism}

\begin{lstlisting}[caption={Parallel Operations with Fork-Join}]
task automatic parallel_operations();
    fork
        begin
            #10 $display("[%0t] Operation 1 complete", $time);
        end
        begin
            #5 $display("[%0t] Operation 2 complete", $time);
        end
        begin
            #15 $display("[%0t] Operation 3 complete", $time);
        end
    join
    $display("[%0t] All parallel operations complete", $time);
endtask

task automatic parallel_with_join_any();
    fork
        begin
            #10 $display("[%0t] Fast operation done", $time);
        end
        begin
            #100 $display("[%0t] Slow operation done", $time);
        end
    join_any
    $display("[%0t] First operation completed", $time);
    disable fork;  // Kill remaining threads
endtask
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 20: Parallel memory test}

Write a task that tests memory using parallel operations:
\begin{itemize}
  \item Fork 4 parallel tasks, each testing different memory region
  \item Use \texttt{join} to wait for all tests
  \item Report results when all complete
\end{itemize}
\end{exercisebox}

\subsection{Extern Functions and Tasks}

The \texttt{extern} keyword allows separation of declaration and definition:

\begin{lstlisting}[caption={Extern Functions and Tasks}]
class DataProcessor;
    // Declaration only (extern)
    extern function void process(int data);
    extern task automatic delayed_process(int data, int delay);
endclass

// Definition outside class
function void DataProcessor::process(int data);
    $display("Processing: %0d", data);
endfunction

task automatic DataProcessor::delayed_process(int data, int delay);
    #delay;
    $display("[%0t] Delayed processing: %0d", $time, data);
endtask
\end{lstlisting}

\subsection{Recursive Functions with Memoization}

Memoization optimizes recursive functions by caching results:

\begin{lstlisting}[caption={Fibonacci with Memoization}]
class Fibonacci;
    static int cache[int];  // Associative array for memoization

    static function int calculate(int n);
        if (cache.exists(n))
            return cache[n];

        if (n <= 1) begin
            cache[n] = n;
            return n;
        end

        cache[n] = calculate(n-1) + calculate(n-2);
        return cache[n];
    endfunction
endclass

module fibonacci_example;
    initial begin
        for (int i = 0; i <= 10; i++)
            $display("Fib(%0d) = %0d", i, Fibonacci::calculate(i));
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 21: Memoized factorial}

Implement a class with a memoized factorial function similar to the Fibonacci example.
\end{exercisebox}

\subsection{DPI (Direct Programming Interface) Functions}

DPI allows calling C/C++ functions from SystemVerilog:

\begin{lstlisting}[caption={DPI Example}]
// Import C function
import "DPI-C" function int c_add(input int a, input int b);
import "DPI-C" function void c_print_message(input string msg);

// Export SystemVerilog function to C
export "DPI-C" function sv_multiply;

function int sv_multiply(int a, int b);
    return a * b;
endfunction

module dpi_example;
    initial begin
        int result;

        // Call C function from SV
        result = c_add(10, 20);
        $display("C function result: %0d", result);

        c_print_message("Hello from SystemVerilog!");
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 22: DPI file operations}

Create DPI functions to:
\begin{itemize}
  \item Open a file in C
  \item Write data from SystemVerilog to file
  \item Read data back
  \item Close file
\end{itemize}
\end{exercisebox}

\subsection{Constraint Functions}

Functions can be used within random constraints:

\begin{lstlisting}[caption={Constraint Functions}]
class ConstrainedData;
    rand bit [7:0] data;
    rand bit [3:0] nibble;

    // Constraint using function
    constraint valid_data {
        is_even(data);
        nibble inside {[0:10]};
    }

    // Function used in constraint
    function bit is_even(bit [7:0] value);
        return (value[0] == 0);
    endfunction
endclass

module constraint_function_example;
    ConstrainedData obj;

    initial begin
        obj = new();
        repeat(5) begin
            assert(obj.randomize());
            $display("Data: %0d (even), Nibble: %0d", obj.data, obj.nibble);
        end
    end
endmodule
\end{lstlisting}

\subsection{Coverage Functions}

Functions calculate and report functional coverage:

\begin{lstlisting}[caption={Functional Coverage with Functions}]
class CoverageCollector;
    bit [7:0] data;

    covergroup cg;
        data_cp: coverpoint data {
            bins low    = {[0:63]};
            bins medium = {[64:127]};
            bins high   = {[128:255]};
        }
    endgroup

    function new();
        cg = new();
    endfunction

    function void sample(bit [7:0] value);
        data = value;
        cg.sample();
    endfunction

    function real get_coverage();
        return cg.get_coverage();
    endfunction
endclass
\end{lstlisting}

\newpage
% ============================================================================
\section{Troubleshooting and Debugging}

\subsection{Common Errors and Solutions}

\begin{warningbox}
\textbf{Error 1: Function with timing control}

\textbf{Error Message:}
\begin{verbatim}
Error: Illegal delay control in function
\end{verbatim}

\textbf{Problem Code:}
\begin{lstlisting}
function int delayed_add(int a, int b);
    #10;  // ERROR!
    return a + b;
endfunction
\end{lstlisting}

\textbf{Solution:}
Use a task instead:
\begin{lstlisting}
task delayed_add(input int a, input int b, output int result);
    #10;
    result = a + b;
endtask
\end{lstlisting}
\end{warningbox}

\begin{warningbox}
\textbf{Error 2: Missing automatic for recursion}

\textbf{Symptom:}
Recursive function returns incorrect results or hangs.

\textbf{Problem Code:}
\begin{lstlisting}
function int factorial(int n);  // Missing automatic!
    if (n <= 1) return 1;
    return n * factorial(n-1);
endfunction
\end{lstlisting}

\textbf{Solution:}
\begin{lstlisting}
function automatic int factorial(int n);  // Add automatic
    if (n <= 1) return 1;
    return n * factorial(n-1);
endfunction
\end{lstlisting}
\end{warningbox}

\begin{warningbox}
\textbf{Error 3: Trying to modify input argument}

\textbf{Error Message:}
\begin{verbatim}
Error: Cannot assign to input argument
\end{verbatim}

\textbf{Problem Code:}
\begin{lstlisting}
function void double_value(input int x);
    x = x * 2;  // ERROR!
endfunction
\end{lstlisting}

\textbf{Solution:}
Use \texttt{ref} or \texttt{output}:
\begin{lstlisting}
function void double_value(ref int x);
    x = x * 2;  // OK with ref
endfunction
\end{lstlisting}
\end{warningbox}

\subsection{Debugging Techniques}

\begin{tipbox}
\textbf{Debugging Tip 1: Add function call tracing}

\begin{lstlisting}
function automatic int fibonacci(int n);
    $display("[TRACE] fibonacci(%0d) called at %0t", n, $time);
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
endfunction
\end{lstlisting}
\end{tipbox}

\begin{tipbox}
\textbf{Debugging Tip 2: Use assertions}

\begin{lstlisting}
function int divide(int a, int b);
    assert (b != 0) else $fatal("Division by zero!");
    return a / b;
endfunction
\end{lstlisting}
\end{tipbox}

\begin{exercisebox}
\textbf{Exercise 23: Debug wrapper}

Create a function wrapper that:
\begin{itemize}
  \item Logs all function calls with arguments
  \item Logs return values
  \item Measures execution time
  \item Counts number of calls
\end{itemize}
\end{exercisebox}

\newpage
% ============================================================================
\section{Exercise Solutions}

\begin{solutionbox}
\textbf{Solution to Exercise 1: Subtract function}

\begin{lstlisting}
function int subtract(int a, int b);
    return a - b;
endfunction

module test_subtract;
    initial begin
        $display("10 - 3 = %0d", subtract(10, 3));    // 7
        $display("100 - 50 = %0d", subtract(100, 50));  // 50
        $display("7 - 12 = %0d", subtract(7, 12));    // -5
    end
endmodule
\end{lstlisting}
\end{solutionbox}

\begin{solutionbox}
\textbf{Solution to Exercise 2: Multiply function}

\begin{lstlisting}
function int multiply(int a, int b);
    return a * b;
endfunction

module test_multiply;
    initial begin
        $display("6 * 7 = %0d", multiply(6, 7));      // 42
        $display("12 * 12 = %0d", multiply(12, 12));  // 144
        $display("-5 * 3 = %0d", multiply(-5, 3));    // -15
    end
endmodule
\end{lstlisting}
\end{solutionbox}

\begin{solutionbox}
\textbf{Solution to Exercise 3: Temperature conversion}

\begin{lstlisting}
function real fahrenheit_to_celsius(real f);
    return (f - 32.0) * 5.0/9.0;
endfunction

function real celsius_to_kelvin(real c);
    return c + 273.15;
endfunction

module test_temperature;
    real f, c, k;

    initial begin
        f = 32.0;
        c = fahrenheit_to_celsius(f);
        k = celsius_to_kelvin(c);
        $display("%0.1f F = %0.1f C = %0.2f K", f, c, k);

        f = 98.6;
        c = fahrenheit_to_celsius(f);
        k = celsius_to_kelvin(c);
        $display("%0.1f F = %0.1f C = %0.2f K", f, c, k);

        f = 212.0;
        c = fahrenheit_to_celsius(f);
        k = celsius_to_kelvin(c);
        $display("%0.1f F = %0.1f C = %0.2f K", f, c, k);
    end
endmodule
\end{lstlisting}

\textbf{Expected Output:}
\begin{verbatim}
32.0 F = 0.0 C = 273.15 K
98.6 F = 37.0 C = 310.15 K
212.0 F = 100.0 C = 373.15 K
\end{verbatim}
\end{solutionbox}

\begin{solutionbox}
\textbf{Solution to Exercise 4: Fibonacci sequence}

\begin{lstlisting}
function automatic int fibonacci(int n);
    if (n <= 0) return 0;
    if (n == 1) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
endfunction

module test_fibonacci;
    initial begin
        $display("Fibonacci Sequence:");
        for (int i = 0; i <= 15; i++)
            $display("fib(%2d) = %5d", i, fibonacci(i));
    end
endmodule
\end{lstlisting}

\textbf{Expected Output:}
\begin{verbatim}
fib( 0) =     0
fib( 1) =     1
fib( 2) =     1
...
fib(15) =   610
\end{verbatim}
\end{solutionbox}

\begin{solutionbox}
\textbf{Solution to Exercise 5: Power function}

\begin{lstlisting}
function automatic int power(int base, int exp);
    if (exp == 0) return 1;
    if (exp == 1) return base;
    return base * power(base, exp - 1);
endfunction

module test_power;
    initial begin
        $display("2^10 = %0d", power(2, 10));   // 1024
        $display("3^5 = %0d", power(3, 5));     // 243
        $display("5^3 = %0d", power(5, 3));     // 125
    end
endmodule
\end{lstlisting}
\end{solutionbox}

\begin{solutionbox}
\textbf{Solution to Exercise 12: Stack class}

\begin{lstlisting}
class Stack;
    local int data[];
    local int top_idx;

    function new();
        data = new[100];  // Max 100 elements
        top_idx = -1;
    endfunction

    function void push(int value);
        if (top_idx >= 99) begin
            $error("Stack overflow!");
            return;
        end
        data[++top_idx] = value;
    endfunction

    function int pop();
        if (is_empty()) begin
            $error("Stack underflow!");
            return 0;
        end
        return data[top_idx--];
    endfunction

    function bit is_empty();
        return (top_idx < 0);
    endfunction

    function int peek();
        if (is_empty()) begin
            $error("Stack is empty!");
            return 0;
        end
        return data[top_idx];
    endfunction

    function int size();
        return top_idx + 1;
    endfunction
endclass

module test_stack;
    Stack s;

    initial begin
        s = new();
        s.push(10);
        s.push(20);
        s.push(30);
        $display("Size: %0d", s.size());      // 3
        $display("Top: %0d", s.peek());       // 30
        $display("Pop: %0d", s.pop());        // 30
        $display("Pop: %0d", s.pop());        // 20
        $display("Size: %0d", s.size());      // 1
    end
endmodule
\end{lstlisting}
\end{solutionbox}

% Continue with more solutions...

\newpage
% ============================================================================
\section{Best Practices}

\subsection{Use Automatic for Recursive or Reentrant Code}

Always use the \texttt{automatic} keyword for recursive functions and reentrant tasks:

\begin{lstlisting}[caption={Proper Use of Automatic}]
// GOOD: Automatic for recursion
function automatic int recursive_sum(int n);
    if (n <= 0) return 0;
    return n + recursive_sum(n-1);
endfunction

// BAD: Static for recursion (causes issues)
function int bad_recursive_sum(int n);
    if (n <= 0) return 0;
    return n + bad_recursive_sum(n-1);  // Shares variables!
endfunction
\end{lstlisting}

\subsection{Prefer Functions Over Tasks When Possible}

Use functions for pure computations:

\begin{lstlisting}[caption={Functions vs Tasks for Computation}]
// GOOD: Function for pure computation
function int max(int a, int b);
    return (a > b) ? a : b;
endfunction

// LESS IDEAL: Task for simple computation
task get_max(input int a, input int b, output int result);
    result = (a > b) ? a : b;
endtask
\end{lstlisting}

\subsection{Use Void Functions for Side Effects Only}

\begin{lstlisting}[caption={Void Functions for Side Effects}]
// GOOD: Clear intent
function void validate_config(Config cfg);
    assert(cfg.timeout > 0) else $error("Invalid timeout");
    assert(cfg.width inside {8, 16, 32}) else $error("Invalid width");
endfunction
\end{lstlisting}

\subsection{Document Function/Task Interfaces}

\begin{lstlisting}[caption={Well-Documented Function}]
/// Converts temperature from Celsius to Fahrenheit
/// @param celsius Temperature in Celsius
/// @return Temperature in Fahrenheit
function real celsius_to_fahrenheit(real celsius);
    return (celsius * 9.0/5.0) + 32.0;
endfunction
\end{lstlisting}

\subsection{Use Ref for Large Data Structures}

\begin{lstlisting}[caption={Using Ref for Large Structures}]
typedef struct {
    bit [31:0] data[1024];
    int size;
} large_packet_t;

// GOOD: Use ref to avoid copying
function void process_packet(ref large_packet_t pkt);
    for (int i = 0; i < pkt.size; i++)
        pkt.data[i] = ~pkt.data[i];
endfunction
\end{lstlisting}

\subsection{Keep Functions Pure When Possible}

\begin{lstlisting}[caption={Pure vs Impure Functions}]
// GOOD: Pure function (no side effects)
function int calculate_checksum(bit [7:0] data[]);
    int checksum = 0;
    foreach(data[i])
        checksum += data[i];
    return checksum;
endfunction

// LESS IDEAL: Function with side effects
function int calculate_and_log_checksum(bit [7:0] data[]);
    int checksum = 0;
    foreach(data[i])
        checksum += data[i];
    $display("Checksum: %0d", checksum);  // Side effect
    return checksum;
endfunction
\end{lstlisting}

\newpage
% ============================================================================
\section{Quick Reference Guide}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|l|p{5.5cm}|}
\hline
\textbf{Feature} & \textbf{Syntax} & \textbf{Use Case} \\
\hline
Basic Function & \texttt{function int f(int a);} & Return single value \\
\hline
Void Function & \texttt{function void f();} & Side effects only \\
\hline
Automatic Function & \texttt{function automatic ...} & Recursion, concurrency \\
\hline
Static Function & \texttt{function static ...} & Preserve state \\
\hline
Default Args & \texttt{function f(int a=0);} & Optional parameters \\
\hline
Output Arg & \texttt{function f(output int x);} & Multiple returns \\
\hline
Ref Arg & \texttt{function f(ref int x);} & Modify original, avoid copy \\
\hline
Virtual Function & \texttt{virtual function f();} & Polymorphism \\
\hline
Pure Virtual & \texttt{pure virtual function f();} & Abstract class \\
\hline
Basic Task & \texttt{task t(input int a);} & Multiple outputs \\
\hline
Task with Timing & \texttt{task t(); \#10; endtask} & Delays, waits \\
\hline
Automatic Task & \texttt{task automatic t();} & Concurrent execution \\
\hline
\end{tabular}
\caption{Quick Syntax Reference}
\end{table}

\subsection{Decision Flowchart}

\textbf{Function/Task Selection Guide:}

\begin{verbatim}
Need subroutine
      |
      v
Need timing control? ----Yes----> TASK
      |                             |
      No                            v
      |                        Concurrent? --Yes--> automatic TASK
      v                             |
Return value? ----No----> Void      No
      |                   FUNCTION  |
      Yes                           v
      |                          static TASK
      v
   FUNCTION
      |
      v
Recursive? ----Yes----> automatic FUNCTION
      |
      No
      |
      v
   static FUNCTION
\end{verbatim}

% ============================================================================
\section{Summary and Next Steps}

\subsection{What You've Learned}

\begin{itemize}
    \item \textbf{Beginner}: Basic function and task syntax, parameters, return values
    \item \textbf{Intermediate}: Advanced features - ref, automatic, default args, class methods
    \item \textbf{Advanced}: Polymorphism, virtual functions, DPI, real-world protocol drivers
    \item \textbf{Practical}: Complete UART and AXI examples, debugging techniques
\end{itemize}

\subsection{Key Takeaways}

\begin{enumerate}
    \item Use \textbf{functions} for pure computations, \textbf{tasks} for timing
    \item Always use \textbf{automatic} for recursion and concurrent operations
    \item Use \textbf{ref} for large data structures to avoid copying
    \item \textbf{Virtual functions} enable powerful polymorphism
    \item Real-world verification uses both functions and tasks extensively
\end{enumerate}

\subsection{Next Steps}

\begin{itemize}
    \item Practice all exercises - hands-on is essential
    \item Study the real-world examples in detail
    \item Implement your own protocol drivers
    \item Explore UVM methodology (builds heavily on these concepts)
    \item Read IEEE 1800-2017 standard for complete details
\end{itemize}

\subsection{Additional Resources}

\begin{itemize}
    \item \textbf{IEEE 1800-2017 SystemVerilog Standard}
    \item \textit{SystemVerilog for Verification} by Chris Spear \& Greg Tumbush
    \item \textit{Writing Testbenches using SystemVerilog} by Janick Bergeron
    \item \textit{SystemVerilog for Design} by Stuart Sutherland
    \item Online simulators: EDA Playground, VerilatorOnline
\end{itemize}

% ============================================================================
\vfill
\begin{center}
\rule{0.5\textwidth}{0.4pt}\\
\Large\textbf{Congratulations!}\\
\normalsize
You've completed the comprehensive guide to\\
SystemVerilog Functions and Tasks\\
\vspace{0.5cm}
\textit{Document Version: 2.0 - Complete Learning Edition}\\
\textit{Last Updated: \today}\\
\vspace{0.5cm}
\small
This document contains ALL original content with fixed package dependencies\\
for compatibility with all LaTeX compilers
\end{center}

\end{document}
