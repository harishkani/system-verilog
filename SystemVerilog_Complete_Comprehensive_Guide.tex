\documentclass[11pt,a4paper]{article}

% Basic packages - compatible with all online compilers
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{multicol}

% Colors
\definecolor{commentgreen}{RGB}{34,139,34}
\definecolor{stringcolor}{RGB}{208,76,239}
\definecolor{keywordcolor}{RGB}{0,0,255}
\definecolor{backgroundcolor}{RGB}{248,248,248}
\definecolor{numbercolor}{RGB}{128,128,128}
\definecolor{exercisecolor}{RGB}{255,250,205}
\definecolor{solutioncolor}{RGB}{230,255,230}
\definecolor{warningcolor}{RGB}{255,230,230}
\definecolor{tipcolor}{RGB}{230,240,255}
\definecolor{quizcolor}{RGB}{255,240,245}
\definecolor{notecolor}{RGB}{255,248,220}

% SystemVerilog language definition
\lstdefinelanguage{SystemVerilog}{
  alsoletter={@,\$},
  morekeywords={
    module, endmodule, input, output, inout, wire, reg, logic, bit,
    always, always_ff, always_comb, always_latch, initial, begin, end,
    if, else, case, endcase, for, while, repeat, forever, do,
    function, endfunction, task, endtask, return, automatic, static,
    class, endclass, new, extends, virtual, pure, extern, this, super,
    typedef, struct, packed, enum, union, interface, endinterface, modport,
    fork, join, join_any, join_none, disable, wait, wait_order,
    rand, randc, constraint, randomize, covergroup, endgroup, coverpoint,
    bins, import, export, ref, const, local, protected, string, int, byte,
    real, void, assert, assume, cover, property, sequence, expect,
    clocking, endclocking, program, endprogram, package, endpackage,
    timeunit, timeprecision, unique, priority, final, with, inside,
    shortint, longint, time, shortreal, chandle, null, signed, unsigned,
    supply0, supply1, tri, triand, trior, tri0, tri1, uwire, wand, wor,
    genvar, generate, endgenerate, localparam, parameter,
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\lstset{
  language=SystemVerilog,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{keywordcolor}\bfseries,
  commentstyle=\color{commentgreen}\itshape,
  stringstyle=\color{stringcolor},
  numberstyle=\tiny\color{numbercolor},
  backgroundcolor=\color{backgroundcolor},
  frame=single,
  rulecolor=\color{black!30},
  numbers=left,
  numbersep=8pt,
  tabsize=4,
  breaklines=true,
  breakatwhitespace=false,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=15pt,
  xrightmargin=5pt,
  aboveskip=10pt,
  belowskip=10pt,
  keepspaces=true,
  columns=flexible
}

% Colored boxes
\newenvironment{coloredbox}[2]{%
  \par\medskip\noindent
  \begin{minipage}{\linewidth}
  \setlength{\fboxsep}{10pt}%
  \fcolorbox{#1!75!black}{#1}{%
  \begin{minipage}{0.95\linewidth}%
  \textbf{#2}\\[5pt]%
}{%
  \end{minipage}}%
  \end{minipage}%
  \medskip\par
}

\newenvironment{exercisebox}{\begin{coloredbox}{exercisecolor}{Exercise}}{\end{coloredbox}}
\newenvironment{solutionbox}{\begin{coloredbox}{solutioncolor}{Solution}}{\end{coloredbox}}
\newenvironment{warningbox}{\begin{coloredbox}{warningcolor}{Warning}}{\end{coloredbox}}
\newenvironment{tipbox}{\begin{coloredbox}{tipcolor}{Tip}}{\end{coloredbox}}
\newenvironment{quizbox}{\begin{coloredbox}{quizcolor}{Quiz}}{\end{coloredbox}}
\newenvironment{notebox}{\begin{coloredbox}{notecolor}{Note}}{\end{coloredbox}}

% Hyperref setup
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
  pdftitle={The Complete SystemVerilog Guide: From Beginner to Expert},
  pdfauthor={},
  pdfsubject={SystemVerilog Programming and Verification},
  pdfkeywords={SystemVerilog, HDL, Verification, UVM, OOP},
  bookmarksnumbered=true,
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Complete SystemVerilog Guide}
\fancyhead[R]{\thepage}
\fancyfoot[C]{From Beginner to Expert - 100+ Exercises}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Title formatting
\titleformat{\section}
  {\normalfont\Large\bfseries\color{blue!70!black}}
  {\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{blue!50!black}}
  {\thesubsection}{1em}{}
\titleformat{\subsubsection}
  {\normalfont\normalsize\bfseries\color{blue!30!black}}
  {\thesubsubsection}{1em}{}

% Title
\title{
  \vspace{-2cm}
  \Huge\textbf{The Complete SystemVerilog Guide} \\
  \LARGE From Beginner to Expert \\
  \Large With 100+ Exercises and Real-World Examples \\
  \vspace{0.5cm}
  \large Comprehensive Coverage: Data Types, OOP, Interfaces, Verification
}
\author{}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This is the most comprehensive SystemVerilog learning resource available, designed to take you from absolute beginner to expert level. This guide includes:

\begin{itemize}
  \item \textbf{Complete Coverage}: All SystemVerilog concepts from basic syntax to advanced verification
  \item \textbf{100+ Hands-on Exercises}: Progressive learning with detailed solutions
  \item \textbf{Real-World Examples}: Complete testbenches, protocol drivers, and verification components
  \item \textbf{20+ Sections}: Organized from beginner through intermediate to advanced topics
  \item \textbf{Visual Aids}: Timing diagrams, memory layouts, class hierarchies, and flowcharts
  \item \textbf{Self-Assessment Quizzes}: Test your knowledge after each major section
  \item \textbf{Best Practices}: Industry-standard coding guidelines and optimization techniques
\end{itemize}

\textbf{Scope}: This guide covers beginner level (Sections 1-10), intermediate level (Sections 11-20), and advanced level (Sections 21-30+), making it suitable for:
\begin{itemize}
  \item Self-study and online learning
  \item University courses in digital design and verification
  \item Professional training and reference
  \item Interview preparation for ASIC/FPGA positions
\end{itemize}
\end{abstract}

\tableofcontents
\newpage

% ============================================================================
\section{How to Use This Complete Guide}

\subsection{Document Organization}

This guide is divided into three main levels:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Level} & \textbf{Sections} & \textbf{Topics Covered} \\
\hline
Beginner & 1-10 & Basic syntax, data types, operators, procedural blocks \\
Intermediate & 11-20 & Advanced types, arrays, interfaces, OOP, packages \\
Advanced & 21-30+ & Verification, UVM, assertions, advanced patterns \\
\hline
\end{tabular}
\caption{Guide Organization}
\end{table}

\subsection{Learning Path}

\textbf{Recommended Study Approach:}

\begin{enumerate}
  \item \textbf{Read Theory}: Understand concepts with clear explanations
  \item \textbf{Study Examples}: Examine working code demonstrating each concept
  \item \textbf{Practice Exercises}: Complete hands-on exercises (essential!)
  \item \textbf{Check Solutions}: Review detailed solutions with explanations
  \item \textbf{Take Quizzes}: Self-assess your understanding
  \item \textbf{Build Projects}: Apply knowledge to real-world scenarios
\end{enumerate}

\subsection{Time Commitment}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Goal} & \textbf{Time Required} & \textbf{Focus Areas} \\
\hline
Beginner Proficiency & 20-30 hours & Sections 1-10, Exercises 1-30 \\
Intermediate Skills & 30-40 hours & Sections 11-20, Exercises 31-70 \\
Advanced Mastery & 40-60 hours & Sections 21-30, Exercises 71-100+ \\
Complete Expertise & 100+ hours & All sections, all exercises, projects \\
\hline
\end{tabular}
\caption{Estimated Learning Timeline}
\end{table}

\subsection{Prerequisites}

\begin{itemize}
  \item \textbf{Required}: Basic digital logic concepts (AND, OR, flip-flops, registers)
  \item \textbf{Helpful}: Programming experience in any language (C, Python, Java, etc.)
  \item \textbf{Helpful}: Familiarity with Verilog (but not required)
  \item \textbf{Tools}: Access to a SystemVerilog simulator:
  \begin{itemize}
    \item Commercial: ModelSim, VCS, Xcelium, Riviera-PRO
    \item Open-source: Verilator, Icarus Verilog (partial SV support)
    \item Online: EDA Playground (\url{https://www.edaplayground.com})
  \end{itemize}
\end{itemize}

\newpage
% ============================================================================
% BEGINNER LEVEL - SECTIONS 1-10 (Brief Overview)
% ============================================================================

\part{Beginner Level (Sections 1-10)}

\textit{Note: Sections 1-10 provide foundational knowledge. The main focus of this document is Intermediate (11-20) and Advanced (21+) topics.}

% ============================================================================
\section{Introduction to SystemVerilog}

\subsection{What is SystemVerilog?}

SystemVerilog is a hardware description and verification language that combines:
\begin{itemize}
  \item \textbf{Verilog HDL}: For hardware design
  \item \textbf{Object-Oriented Programming}: Classes, inheritance, polymorphism
  \item \textbf{Advanced Verification}: Constraints, coverage, assertions
  \item \textbf{Interface Modeling}: Abstract communication protocols
\end{itemize}

\subsection{Why Learn SystemVerilog?}

\begin{itemize}
  \item Industry standard for ASIC and FPGA verification
  \item Unified language for design and verification
  \item Required for UVM (Universal Verification Methodology)
  \item Strong job market demand
  \item Powerful features for complex systems
\end{itemize}

% ============================================================================
\section{Basic Data Types}

\subsection{Two-State vs Four-State}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Type} & \textbf{States} & \textbf{Use Case} \\
\hline
\texttt{bit} & 0, 1 & Testbenches, fast simulation \\
\texttt{byte} & 0, 1 & 8-bit signed integer \\
\texttt{int} & 0, 1 & 32-bit signed integer \\
\texttt{logic} & 0, 1, X, Z & Hardware signals \\
\texttt{reg} & 0, 1, X, Z & Legacy Verilog (use logic) \\
\hline
\end{tabular}
\caption{Common Data Types}
\end{table}

\begin{lstlisting}[caption={Basic Data Type Examples}]
module data_types_intro;
    // Two-state types (faster simulation)
    bit        single_bit;        // 0 or 1
    bit [7:0]  byte_val;          // 8-bit vector
    int        signed_int = -42;  // 32-bit signed

    // Four-state types (hardware modeling)
    logic      signal;            // Can be 0, 1, X, Z
    logic [15:0] address;         // 16-bit bus

    // String
    string     message = "Hello, SystemVerilog!";

    // Real numbers
    real       voltage = 3.3;
    shortreal  temperature = 25.5;

    initial begin
        $display("Int value: %0d", signed_int);
        $display("Message: %s", message);
        $display("Voltage: %0.2f V", voltage);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Operators and Expressions}

\subsection{Arithmetic Operators}

\begin{lstlisting}[caption={Arithmetic Operations}]
module arithmetic_examples;
    int a = 10, b = 3, result;

    initial begin
        result = a + b;    // Addition: 13
        result = a - b;    // Subtraction: 7
        result = a * b;    // Multiplication: 30
        result = a / b;    // Integer division: 3
        result = a % b;    // Modulo: 1
        result = a ** b;   // Power: 1000

        $display("10 / 3 = %0d", a / b);
        $display("10 %% 3 = %0d", a % b);
        $display("10 ** 3 = %0d", a ** b);
    end
endmodule
\end{lstlisting}

\subsection{Bitwise and Reduction Operators}

\begin{lstlisting}[caption={Bitwise Operations}]
module bitwise_examples;
    bit [7:0] a = 8'b10110010;
    bit [7:0] b = 8'b11001100;
    bit [7:0] result;
    bit parity;

    initial begin
        // Bitwise operators
        result = a & b;    // AND: 10000000
        result = a | b;    // OR:  11111110
        result = a ^ b;    // XOR: 01111110
        result = ~a;       // NOT: 01001101

        // Reduction operators
        parity = ^a;       // XOR of all bits (parity)

        $display("a & b = %b", a & b);
        $display("a | b = %b", a | b);
        $display("a ^ b = %b", a ^ b);
        $display("Parity of a = %b", ^a);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Procedural Blocks}

\subsection{Always Blocks}

SystemVerilog provides three types of always blocks:

\begin{lstlisting}[caption={Always Block Types}]
module always_block_types(
    input  logic clk,
    input  logic rst_n,
    input  logic [7:0] data_in,
    output logic [7:0] data_out,
    output logic [7:0] combo_out
);
    // Sequential logic - flip-flops
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            data_out <= 8'h00;
        else
            data_out <= data_in;
    end

    // Combinational logic
    always_comb begin
        combo_out = data_in + 8'd1;
    end

    // Latch (usually avoid these!)
    logic [7:0] latch_out;
    always_latch begin
        if (clk)
            latch_out = data_in;
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Control Flow}

\subsection{If-Else Statements}

\begin{lstlisting}[caption={If-Else Example}]
module priority_encoder(
    input  logic [7:0] data,
    output logic [2:0] encoded,
    output logic       valid
);
    always_comb begin
        if (data[7]) begin
            encoded = 3'd7;
            valid = 1'b1;
        end else if (data[6]) begin
            encoded = 3'd6;
            valid = 1'b1;
        end else if (data[5]) begin
            encoded = 3'd5;
            valid = 1'b1;
        end else if (data[4]) begin
            encoded = 3'd4;
            valid = 1'b1;
        end else if (data[3]) begin
            encoded = 3'd3;
            valid = 1'b1;
        end else if (data[2]) begin
            encoded = 3'd2;
            valid = 1'b1;
        end else if (data[1]) begin
            encoded = 3'd1;
            valid = 1'b1;
        end else if (data[0]) begin
            encoded = 3'd0;
            valid = 1'b1;
        end else begin
            encoded = 3'd0;
            valid = 1'b0;
        end
    end
endmodule
\end{lstlisting}

\subsection{Case Statements}

\begin{lstlisting}[caption={Case Statement Example}]
module alu(
    input  logic [3:0] opcode,
    input  logic [7:0] a, b,
    output logic [7:0] result
);
    always_comb begin
        case (opcode)
            4'h0: result = a + b;      // ADD
            4'h1: result = a - b;      // SUB
            4'h2: result = a & b;      // AND
            4'h3: result = a | b;      // OR
            4'h4: result = a ^ b;      // XOR
            4'h5: result = ~a;         // NOT
            4'h6: result = a << 1;     // Shift left
            4'h7: result = a >> 1;     // Shift right
            default: result = 8'h00;   // Default case
        endcase
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Loops}

\subsection{For Loops}

\begin{lstlisting}[caption={For Loop Examples}]
module loop_examples;
    initial begin
        // Simple counting
        for (int i = 0; i < 10; i++) begin
            $display("Count: %0d", i);
        end

        // Array initialization
        int array[8];
        for (int i = 0; i < 8; i++) begin
            array[i] = i * 2;
        end

        // Display array
        for (int i = 0; i < 8; i++) begin
            $display("array[%0d] = %0d", i, array[i]);
        end
    end
endmodule
\end{lstlisting}

\subsection{While and Do-While Loops}

\begin{lstlisting}[caption={While Loop Examples}]
module while_examples;
    initial begin
        int count = 0;

        // While loop
        while (count < 5) begin
            $display("While: %0d", count);
            count++;
        end

        // Do-while loop
        count = 0;
        do begin
            $display("Do-While: %0d", count);
            count++;
        end while (count < 5);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Functions and Tasks - Brief Introduction}

\textit{(Detailed coverage in the Functions \& Tasks guide)}

\subsection{Basic Function}

\begin{lstlisting}[caption={Simple Function}]
function int add(int a, int b);
    return a + b;
endfunction

module function_example;
    int result;

    initial begin
        result = add(5, 3);
        $display("5 + 3 = %0d", result);
    end
endmodule
\end{lstlisting}

\subsection{Basic Task}

\begin{lstlisting}[caption={Simple Task}]
task display_value(input int value);
    $display("[%0t] Value: %0d", $time, value);
endtask

module task_example;
    initial begin
        display_value(42);
        #10;
        display_value(100);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Structures and Unions}

\subsection{Packed vs Unpacked Structures}

\begin{lstlisting}[caption={Structure Examples}]
module structure_examples;
    // Unpacked structure (individual fields)
    typedef struct {
        int         id;
        string      name;
        real        salary;
    } employee_t;

    // Packed structure (can be treated as vector)
    typedef struct packed {
        logic [7:0] opcode;
        logic [3:0] dest_reg;
        logic [3:0] src_reg;
    } instruction_t;

    initial begin
        employee_t emp;
        emp.id = 1001;
        emp.name = "John Doe";
        emp.salary = 75000.00;

        $display("Employee: %s (ID: %0d) - $%0.2f",
                 emp.name, emp.id, emp.salary);

        instruction_t instr;
        instr.opcode = 8'hA5;
        instr.dest_reg = 4'h3;
        instr.src_reg = 4'h7;

        $display("Instruction: %h", instr);  // Treated as 16-bit value
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Enumerations}

\begin{lstlisting}[caption={Enumeration Examples}]
module enum_examples;
    // Basic enumeration
    typedef enum {
        IDLE, ACTIVE, WAITING, DONE
    } state_t;

    // Enumeration with explicit values
    typedef enum logic [2:0] {
        RED   = 3'b001,
        YELLOW = 3'b010,
        GREEN = 3'b100
    } traffic_light_t;

    // Enumeration with type
    typedef enum int {
        ERROR = -1,
        SUCCESS = 0,
        PENDING = 1
    } status_t;

    state_t current_state;
    traffic_light_t light;
    status_t result;

    initial begin
        current_state = IDLE;
        light = GREEN;
        result = SUCCESS;

        $display("State: %s", current_state.name());
        $display("Light: %s", light.name());
        $display("Result: %s (%0d)", result.name(), result);
    end
endmodule
\end{lstlisting}

% ============================================================================
\section{Fixed-Size Arrays}

\begin{lstlisting}[caption={Fixed Array Examples}]
module fixed_array_examples;
    // 1D array
    int numbers[10];          // Array of 10 integers

    // 2D array
    bit [7:0] matrix[4][8];   // 4x8 matrix of bytes

    // Multidimensional array
    logic [3:0] cube[2][3][4]; // 3D array

    initial begin
        // Initialize 1D array
        for (int i = 0; i < 10; i++) begin
            numbers[i] = i * i;
        end

        // Initialize 2D array
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 8; j++) begin
                matrix[i][j] = i * 8 + j;
            end
        end

        // Display arrays
        $display("Numbers: %p", numbers);
        $display("Matrix[0]: %p", matrix[0]);
    end
endmodule
\end{lstlisting}

\newpage
% ============================================================================
% INTERMEDIATE LEVEL - SECTIONS 11-20 (DETAILED)
% ============================================================================

\part{Intermediate Level (Sections 11-20)}

\textit{This is the main focus of the document. These sections provide comprehensive coverage with extensive examples and exercises.}

% ============================================================================
\section{Advanced Data Types and Typedef}

\subsection{Understanding Typedef}

The \texttt{typedef} keyword creates user-defined types, improving code readability and maintainability.

\begin{lstlisting}[caption={Typedef Basics}]
module typedef_examples;
    // Basic typedef for primitive types
    typedef bit [31:0] word_t;
    typedef bit [15:0] halfword_t;
    typedef bit [7:0]  byte_t;

    // Typedef for arrays
    typedef byte_t byte_array_t[256];

    // Using typedefs
    word_t program_counter;
    halfword_t instruction;
    byte_array_t memory;

    initial begin
        program_counter = 32'h0000_1000;
        instruction = 16'hA5F0;
        memory[0] = 8'hFF;

        $display("PC: 0x%h", program_counter);
        $display("Instruction: 0x%h", instruction);
        $display("Memory[0]: 0x%h", memory[0]);
    end
endmodule
\end{lstlisting}

\subsection{Complex Typedef Patterns}

\begin{lstlisting}[caption={Advanced Typedef Usage}]
module complex_typedef;
    // Typedef for function signature
    typedef function int math_func_t(int a, int b);

    // Typedef for structure
    typedef struct packed {
        logic        valid;
        logic [3:0]  id;
        logic [31:0] data;
        logic [3:0]  strobe;
    } axi_data_t;

    // Typedef for enum
    typedef enum logic [2:0] {
        RESET   = 3'b000,
        FETCH   = 3'b001,
        DECODE  = 3'b010,
        EXECUTE = 3'b011,
        WRITEBACK = 3'b100
    } cpu_state_t;

    // Typedef for parameterized structure
    parameter int DATA_WIDTH = 32;
    typedef struct packed {
        logic                  valid;
        logic [DATA_WIDTH-1:0] data;
    } data_packet_t;

    // Using the types
    axi_data_t axi_transaction;
    cpu_state_t current_state, next_state;
    data_packet_t packet;

    initial begin
        // Initialize AXI transaction
        axi_transaction.valid = 1'b1;
        axi_transaction.id = 4'h5;
        axi_transaction.data = 32'hDEADBEEF;
        axi_transaction.strobe = 4'hF;

        // State machine
        current_state = RESET;
        next_state = FETCH;

        // Packet
        packet.valid = 1'b1;
        packet.data = 32'h12345678;

        $display("AXI Transaction: %p", axi_transaction);
        $display("State: %s -> %s", current_state.name(), next_state.name());
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 24: Create a Register File Type}

Define a typedef for a register file with:
\begin{itemize}
  \item 32 registers, each 32 bits wide
  \item Structure with fields: \texttt{data[32]}, \texttt{valid[32]}, \texttt{dirty[32]}
  \item Function to read a register
  \item Function to write a register
\end{itemize}

Test with reading and writing several registers.
\end{exercisebox}

\subsection{Advanced Struct Features}

\begin{lstlisting}[caption={Advanced Structures with Methods}]
module struct_with_defaults;
    // Structure with default values
    typedef struct {
        int         size;
        string      name;
        logic [7:0] data[];

        // You cannot define methods in structs (use classes instead)
    } packet_t;

    // Tagged unions
    typedef union tagged {
        int         int_val;
        real        real_val;
        string      str_val;
    } variant_t;

    initial begin
        packet_t pkt;
        pkt.size = 4;
        pkt.name = "Test Packet";
        pkt.data = new[4];
        pkt.data = '{8'hAA, 8'hBB, 8'hCC, 8'hDD};

        $display("Packet: %s, Size: %0d", pkt.name, pkt.size);
        $display("Data: %p", pkt.data);
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 25: Network Packet Typedef}

Create typedefs for:
\begin{itemize}
  \item \texttt{mac\_addr\_t} - 48-bit MAC address
  \item \texttt{ipv4\_addr\_t} - 32-bit IP address
  \item \texttt{eth\_header\_t} - Ethernet header (dest MAC, src MAC, EtherType)
  \item \texttt{ipv4\_header\_t} - IPv4 header (version, length, src IP, dest IP, protocol)
  \item \texttt{network\_packet\_t} - Complete packet with both headers and payload
\end{itemize}

Create a function that prints all fields of a network packet.
\end{exercisebox}

\subsection{Quiz: Advanced Data Types}

\begin{quizbox}
\textbf{Quiz 4: Typedef and Advanced Types}

\begin{enumerate}
  \item What is the purpose of typedef? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can you use typedef to create a new function type? (Yes/No) \_\_\_\_\_\_
  \item What's the difference between packed and unpacked structs?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can structures contain dynamic arrays? (Yes/No) \_\_\_\_\_\_
  \item What keyword is used for discriminated unions? \_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item To create user-defined type aliases for better code readability and maintainability
  \item Yes
  \item Packed structs are stored as contiguous bits (can be treated as vectors); unpacked structs have independent fields
  \item Yes
  \item \texttt{tagged}
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Dynamic Arrays}

\subsection{Introduction to Dynamic Arrays}

Dynamic arrays can be sized and resized during simulation, making them ideal for testbenches and verification.

\begin{lstlisting}[caption={Dynamic Array Basics}]
module dynamic_array_intro;
    int dynamic_arr[];  // Declaration (size unknown)

    initial begin
        // Allocate memory for 10 elements
        dynamic_arr = new[10];

        // Initialize array
        for (int i = 0; i < 10; i++) begin
            dynamic_arr[i] = i * 10;
        end

        // Display array
        $display("Array size: %0d", dynamic_arr.size());
        $display("Array contents: %p", dynamic_arr);

        // Resize array (preserves existing values)
        dynamic_arr = new[15](dynamic_arr);
        $display("After resize: %0d elements", dynamic_arr.size());

        // Initialize new elements
        for (int i = 10; i < 15; i++) begin
            dynamic_arr[i] = i * 10;
        end

        $display("Resized array: %p", dynamic_arr);
    end
endmodule
\end{lstlisting}

\subsection{Dynamic Array Methods}

\begin{lstlisting}[caption={Dynamic Array Built-in Methods}]
module dynamic_array_methods;
    int numbers[];
    int sum, product;

    initial begin
        // Create and initialize
        numbers = new[5];
        numbers = '{10, 20, 30, 40, 50};

        // size() - returns number of elements
        $display("Size: %0d", numbers.size());

        // sum() - sum of all elements (only for integral types)
        sum = numbers.sum();
        $display("Sum: %0d", sum);

        // product() - product of all elements
        product = numbers.product();
        $display("Product: %0d", product);

        // Array iteration with foreach
        $display("Elements:");
        foreach(numbers[i]) begin
            $display("  numbers[%0d] = %0d", i, numbers[i]);
        end

        // delete() - deallocate array
        numbers.delete();
        $display("After delete, size: %0d", numbers.size());
    end
endmodule
\end{lstlisting}

\subsection{Advanced Dynamic Array Operations}

\begin{lstlisting}[caption={Advanced Dynamic Array Usage}]
module dynamic_array_advanced;
    // Multidimensional dynamic arrays
    int matrix[][];

    // Array of structures
    typedef struct {
        int id;
        string name;
        int score;
    } student_t;

    student_t students[];

    initial begin
        // Create 2D dynamic array
        matrix = new[3];  // 3 rows
        foreach(matrix[i]) begin
            matrix[i] = new[4];  // 4 columns per row
            foreach(matrix[i][j]) begin
                matrix[i][j] = i * 4 + j;
            end
        end

        $display("Matrix:");
        foreach(matrix[i]) begin
            $display("  Row %0d: %p", i, matrix[i]);
        end

        // Array of structures
        students = new[3];
        students[0] = '{id: 1001, name: "Alice", score: 95};
        students[1] = '{id: 1002, name: "Bob", score: 87};
        students[2] = '{id: 1003, name: "Carol", score: 92};

        $display("\nStudents:");
        foreach(students[i]) begin
            $display("  %0d: %s (ID: %0d) - Score: %0d",
                     i, students[i].name, students[i].id, students[i].score);
        end

        // Calculate average score
        int total_score = 0;
        foreach(students[i]) begin
            total_score += students[i].score;
        end
        $display("Average score: %0.2f", real'(total_score) / students.size());
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 26: Dynamic Array Sorting}

Implement a sorting function for a dynamic array:
\begin{itemize}
  \item Function \texttt{sort\_ascending(ref int arr[])} - sorts array in ascending order
  \item Function \texttt{sort\_descending(ref int arr[])} - sorts in descending order
  \item Function \texttt{find\_min(int arr[])} - returns minimum value
  \item Function \texttt{find\_max(int arr[])} - returns maximum value
\end{itemize}

Test with array: \{64, 34, 25, 12, 22, 11, 90\}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 27: Transaction Buffer}

Create a transaction buffer using dynamic arrays:
\begin{itemize}
  \item Structure for transaction: id, address, data, timestamp
  \item Dynamic array to store transactions
  \item Function to add transaction
  \item Function to find transaction by ID
  \item Function to get all transactions in time range
\end{itemize}
\end{exercisebox}

\subsection{Memory Management with Dynamic Arrays}

\begin{lstlisting}[caption={Memory Management Example}]
module memory_manager;
    typedef struct {
        int     address;
        byte    data[];
        int     size;
        realtime timestamp;
    } memory_block_t;

    memory_block_t memory_blocks[];
    int num_blocks = 0;

    // Allocate memory block
    function void allocate_block(int addr, int block_size);
        memory_blocks = new[num_blocks + 1](memory_blocks);
        memory_blocks[num_blocks].address = addr;
        memory_blocks[num_blocks].size = block_size;
        memory_blocks[num_blocks].data = new[block_size];
        memory_blocks[num_blocks].timestamp = $realtime;

        // Initialize with zeros
        for (int i = 0; i < block_size; i++) begin
            memory_blocks[num_blocks].data[i] = 0;
        end

        $display("[%0t] Allocated block %0d at address 0x%h, size %0d bytes",
                 $time, num_blocks, addr, block_size);
        num_blocks++;
    endfunction

    // Write to memory block
    function bit write_block(int block_id, int offset, byte value);
        if (block_id >= num_blocks) begin
            $error("Invalid block ID: %0d", block_id);
            return 0;
        end

        if (offset >= memory_blocks[block_id].size) begin
            $error("Offset %0d out of range for block %0d", offset, block_id);
            return 0;
        end

        memory_blocks[block_id].data[offset] = value;
        $display("[%0t] Write: Block %0d[%0d] = 0x%h",
                 $time, block_id, offset, value);
        return 1;
    endfunction

    // Read from memory block
    function byte read_block(int block_id, int offset);
        if (block_id >= num_blocks || offset >= memory_blocks[block_id].size) begin
            $error("Invalid access");
            return 8'hXX;
        end

        return memory_blocks[block_id].data[offset];
    endfunction

    // Display all blocks
    function void display_blocks();
        $display("\n=== Memory Blocks ===");
        for (int i = 0; i < num_blocks; i++) begin
            $display("Block %0d: Addr=0x%h, Size=%0d, Timestamp=%0t",
                     i, memory_blocks[i].address, memory_blocks[i].size,
                     memory_blocks[i].timestamp);
        end
    endfunction

    initial begin
        // Test memory manager
        allocate_block(32'h1000, 16);
        allocate_block(32'h2000, 32);
        allocate_block(32'h3000, 8);

        // Write some data
        write_block(0, 0, 8'hAA);
        write_block(0, 1, 8'hBB);
        write_block(1, 10, 8'hCC);

        // Read back
        $display("Block 0[0] = 0x%h", read_block(0, 0));
        $display("Block 0[1] = 0x%h", read_block(0, 1));
        $display("Block 1[10] = 0x%h", read_block(1, 10));

        display_blocks();
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 28: Dynamic Matrix Operations}

Implement a matrix library using dynamic arrays:
\begin{itemize}
  \item Function \texttt{create\_matrix(int rows, cols)} - returns new matrix
  \item Function \texttt{add\_matrices(int a[][], int b[][])} - matrix addition
  \item Function \texttt{multiply\_matrices(int a[][], int b[][])} - matrix multiplication
  \item Function \texttt{transpose(int matrix[][])} - matrix transpose
  \item Function \texttt{print\_matrix(int matrix[][])} - display matrix
\end{itemize}

Test with 3x3 matrices.
\end{exercisebox}

\subsection{Quiz: Dynamic Arrays}

\begin{quizbox}
\textbf{Quiz 5: Dynamic Arrays}

\begin{enumerate}
  \item How do you allocate a dynamic array with 20 elements? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What method returns the size of a dynamic array? \_\_\_\_\_\_\_\_\_\_
  \item How do you resize an array while preserving existing values?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can dynamic arrays be multidimensional? (Yes/No) \_\_\_\_\_\_
  \item What happens when you call \texttt{delete()} on a dynamic array? \_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{arr = new[20];}
  \item \texttt{size()}
  \item \texttt{arr = new[new\_size](arr);}
  \item Yes
  \item The array is deallocated and size becomes 0
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Queues}

\subsection{Introduction to Queues}

Queues are dynamic arrays with powerful insertion and deletion methods at both ends.

\begin{lstlisting}[caption={Queue Basics}]
module queue_intro;
    int queue[$];  // Queue declaration ($ means queue)

    initial begin
        // Push elements to back
        queue.push_back(10);
        queue.push_back(20);
        queue.push_back(30);
        $display("After push_back: %p", queue);  // {10, 20, 30}

        // Push element to front
        queue.push_front(5);
        $display("After push_front(5): %p", queue);  // {5, 10, 20, 30}

        // Pop from front
        int value = queue.pop_front();
        $display("Popped from front: %0d", value);  // 5
        $display("Queue now: %p", queue);  // {10, 20, 30}

        // Pop from back
        value = queue.pop_back();
        $display("Popped from back: %0d", value);  // 30
        $display("Queue now: %p", queue);  // {10, 20}

        // Check size
        $display("Queue size: %0d", queue.size());

        // Access like array
        $display("queue[0] = %0d", queue[0]);  // 10
        $display("queue[1] = %0d", queue[1]);  // 20
    end
endmodule
\end{lstlisting}

\subsection{Queue Methods}

\begin{lstlisting}[caption={Comprehensive Queue Operations}]
module queue_methods;
    int q[$];
    int value;

    initial begin
        // Insert operations
        q = {1, 2, 3, 4, 5};
        $display("Initial: %p", q);

        // insert(index, value) - insert at index
        q.insert(2, 99);  // Insert 99 at index 2
        $display("After insert(2, 99): %p", q);  // {1, 2, 99, 3, 4, 5}

        // delete(index) - remove element at index
        q.delete(3);  // Remove element at index 3
        $display("After delete(3): %p", q);  // {1, 2, 99, 4, 5}

        // Bounded queue (max size)
        int bounded_q[$:7];  // Max 8 elements (0 to 7)
        bounded_q = {1, 2, 3};
        $display("Bounded queue: %p, size: %0d", bounded_q, bounded_q.size());

        // Array slicing
        q = {10, 20, 30, 40, 50, 60};
        int slice[$] = q[1:3];  // Elements 1, 2, 3
        $display("Slice q[1:3]: %p", slice);  // {20, 30, 40}

        // Concatenation
        int q1[$] = {1, 2, 3};
        int q2[$] = {4, 5, 6};
        int q3[$] = {q1, q2};  // Concatenate
        $display("Concatenated: %p", q3);  // {1, 2, 3, 4, 5, 6}

        // delete() - clear entire queue
        q.delete();
        $display("After delete(): %p, size: %0d", q, q.size());
    end
endmodule
\end{lstlisting}

\subsection{Queue Use Cases}

\begin{lstlisting}[caption={FIFO and LIFO with Queues}]
module fifo_lifo_example;

    // FIFO (First In, First Out) - Queue behavior
    class FIFO;
        int data[$];

        function void push(int value);
            data.push_back(value);
            $display("FIFO Push: %0d", value);
        endfunction

        function int pop();
            if (data.size() == 0) begin
                $error("FIFO is empty!");
                return -1;
            end
            int value = data.pop_front();
            $display("FIFO Pop: %0d", value);
            return value;
        endfunction

        function int size();
            return data.size();
        endfunction

        function bit is_empty();
            return (data.size() == 0);
        endfunction
    endclass

    // LIFO (Last In, First Out) - Stack behavior
    class LIFO;
        int data[$];

        function void push(int value);
            data.push_back(value);
            $display("LIFO Push: %0d", value);
        endfunction

        function int pop();
            if (data.size() == 0) begin
                $error("LIFO is empty!");
                return -1;
            end
            int value = data.pop_back();
            $display("LIFO Pop: %0d", value);
            return value;
        endfunction

        function int peek();
            if (data.size() == 0) return -1;
            return data[$];  // $ references last element
        endfunction
    endclass

    initial begin
        FIFO fifo = new();
        LIFO lifo = new();

        $display("=== Testing FIFO ===");
        fifo.push(10);
        fifo.push(20);
        fifo.push(30);
        void'(fifo.pop());  // Returns 10
        void'(fifo.pop());  // Returns 20
        void'(fifo.pop());  // Returns 30

        $display("\n=== Testing LIFO (Stack) ===");
        lifo.push(10);
        lifo.push(20);
        lifo.push(30);
        void'(lifo.pop());  // Returns 30
        void'(lifo.pop());  // Returns 20
        void'(lifo.pop());  // Returns 10
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 29: Priority Queue}

Implement a priority queue:
\begin{itemize}
  \item Structure: \texttt{item\_t} with \texttt{data} and \texttt{priority} fields
  \item Function \texttt{enqueue(item\_t item)} - insert maintaining priority order
  \item Function \texttt{dequeue()} - remove highest priority item
  \item Function \texttt{peek()} - view highest priority without removing
  \item Function \texttt{display()} - show all items with priorities
\end{itemize}

Test with items of varying priorities.
\end{exercisebox}

\subsection{Scoreboard with Queues}

\begin{lstlisting}[caption={Verification Scoreboard Using Queues}]
module scoreboard_example;

    typedef struct {
        int         id;
        bit [31:0]  address;
        bit [31:0]  data;
        realtime    timestamp;
    } transaction_t;

    class Scoreboard;
        transaction_t expected_q[$];
        transaction_t actual_q[$];
        int matches = 0;
        int mismatches = 0;

        // Add expected transaction
        function void add_expected(transaction_t trans);
            expected_q.push_back(trans);
            $display("[%0t] Expected: ID=%0d, Addr=0x%h, Data=0x%h",
                     $time, trans.id, trans.address, trans.data);
        endfunction

        // Add actual transaction and compare
        function void add_actual(transaction_t trans);
            actual_q.push_back(trans);
            $display("[%0t] Actual: ID=%0d, Addr=0x%h, Data=0x%h",
                     $time, trans.id, trans.address, trans.data);

            // Try to match with expected
            compare();
        endfunction

        // Compare transactions
        function void compare();
            if (expected_q.size() == 0) begin
                $error("No expected transaction to compare!");
                return;
            end

            if (actual_q.size() == 0) return;

            transaction_t exp = expected_q.pop_front();
            transaction_t act = actual_q.pop_front();

            if (exp.address == act.address && exp.data == act.data) begin
                matches++;
                $display("  [MATCH] ID %0d matched!", exp.id);
            end else begin
                mismatches++;
                $error("  [MISMATCH] Expected: Addr=0x%h Data=0x%h, Got: Addr=0x%h Data=0x%h",
                       exp.address, exp.data, act.address, act.data);
            end
        endfunction

        // Final report
        function void report();
            $display("\n=== Scoreboard Report ===");
            $display("Matches: %0d", matches);
            $display("Mismatches: %0d", mismatches);
            $display("Pending Expected: %0d", expected_q.size());
            $display("Pending Actual: %0d", actual_q.size());

            if (mismatches == 0 && expected_q.size() == 0 && actual_q.size() == 0)
                $display("TEST PASSED!");
            else
                $display("TEST FAILED!");
        endfunction
    endclass

    initial begin
        Scoreboard sb = new();
        transaction_t trans;

        // Add expected transactions
        trans = '{id: 1, address: 32'h1000, data: 32'hAAAA, timestamp: 0};
        sb.add_expected(trans);

        trans = '{id: 2, address: 32'h2000, data: 32'hBBBB, timestamp: 0};
        sb.add_expected(trans);

        trans = '{id: 3, address: 32'h3000, data: 32'hCCCC, timestamp: 0};
        sb.add_expected(trans);

        #10;

        // Add actual transactions
        trans = '{id: 1, address: 32'h1000, data: 32'hAAAA, timestamp: $realtime};
        sb.add_actual(trans);

        #10;
        trans = '{id: 2, address: 32'h2000, data: 32'hBBBB, timestamp: $realtime};
        sb.add_actual(trans);

        #10;
        trans = '{id: 3, address: 32'h3000, data: 32'hCCCC, timestamp: $realtime};
        sb.add_actual(trans);

        #10;
        sb.report();
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 30: Packet Reorder Buffer}

Implement a packet reorder buffer:
\begin{itemize}
  \item Packets arrive out of order with sequence numbers
  \item Store packets in a queue
  \item Function to insert packet in sequence order
  \item Function to retrieve next in-sequence packet
  \item Function to detect missing packets
  \item Function to display buffer state
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Queues}

\begin{quizbox}
\textbf{Quiz 6: Queues}

\begin{enumerate}
  \item How is a queue declared in SystemVerilog? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What's the difference between \texttt{push\_front()} and \texttt{push\_back()}?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can you access queue elements using array indexing? (Yes/No) \_\_\_\_\_\_
  \item What is a bounded queue? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item How do you clear all elements from a queue? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{type name[\$];}
  \item \texttt{push\_front()} adds to beginning; \texttt{push\_back()} adds to end
  \item Yes
  \item A queue with maximum size limit specified as \texttt{\$:max\_size}
  \item \texttt{queue.delete();}
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Associative Arrays}

\subsection{Introduction to Associative Arrays}

Associative arrays store data with arbitrary index types, similar to hash maps or dictionaries.

\begin{lstlisting}[caption={Associative Array Basics}]
module associative_array_intro;
    // Associative array with int index
    int aa_int[int];

    // Associative array with string index
    int aa_string[string];

    // Associative array with custom type
    typedef struct packed {
        logic [15:0] addr;
    } addr_t;

    bit [31:0] memory[addr_t];

    initial begin
        // Using int indices (sparse)
        aa_int[5] = 100;
        aa_int[1000] = 200;
        aa_int[5000] = 300;

        $display("aa_int[5] = %0d", aa_int[5]);
        $display("aa_int[1000] = %0d", aa_int[1000]);
        $display("Number of elements: %0d", aa_int.num());

        // Using string indices
        aa_string["Alice"] = 95;
        aa_string["Bob"] = 87;
        aa_string["Carol"] = 92;

        $display("\nScores:");
        $display("Alice: %0d", aa_string["Alice"]);
        $display("Bob: %0d", aa_string["Bob"]);
        $display("Carol: %0d", aa_string["Carol"]);

        // Using packed struct as index
        addr_t addr1 = 16'h1000;
        addr_t addr2 = 16'h2000;

        memory[addr1] = 32'hDEADBEEF;
        memory[addr2] = 32'hCAFEBABE;

        $display("\nMemory:");
        $display("memory[0x%h] = 0x%h", addr1, memory[addr1]);
        $display("memory[0x%h] = 0x%h", addr2, memory[addr2]);
    end
endmodule
\end{lstlisting}

\subsection{Associative Array Methods}

\begin{lstlisting}[caption={Associative Array Operations}]
module associative_array_methods;
    int scores[string];
    string key;
    int value;

    initial begin
        // Populate associative array
        scores["Alice"] = 95;
        scores["Bob"] = 87;
        scores["Carol"] = 92;
        scores["Dave"] = 88;

        // num() - returns number of entries
        $display("Number of students: %0d", scores.num());

        // exists(index) - check if index exists
        if (scores.exists("Alice")) begin
            $display("Alice's score exists: %0d", scores["Alice"]);
        end

        if (!scores.exists("Eve")) begin
            $display("Eve's score does not exist");
        end

        // first(ref index) - get first index
        if (scores.first(key)) begin
            $display("First: %s = %0d", key, scores[key]);
        end

        // last(ref index) - get last index
        if (scores.last(key)) begin
            $display("Last: %s = %0d", key, scores[key]);
        end

        // next(ref index) - iterate through all entries
        $display("\nAll scores (using next):");
        if (scores.first(key)) begin
            do begin
                $display("  %s: %0d", key, scores[key]);
            end while (scores.next(key));
        end

        // prev(ref index) - iterate backwards
        $display("\nAll scores (reverse using prev):");
        if (scores.last(key)) begin
            do begin
                $display("  %s: %0d", key, scores[key]);
            end while (scores.prev(key));
        end

        // delete(index) - remove specific entry
        scores.delete("Bob");
        $display("\nAfter deleting Bob: %0d entries", scores.num());

        // delete() - remove all entries
        scores.delete();
        $display("After delete all: %0d entries", scores.num());
    end
endmodule
\end{lstlisting}

\subsection{Practical Associative Array Examples}

\begin{lstlisting}[caption={Cache Memory Model with Associative Array}]
module cache_model;

    class CacheMemory;
        typedef bit [31:0] addr_t;
        typedef bit [31:0] data_t;

        // Associative array for cache storage
        data_t cache[addr_t];

        // Statistics
        int hits = 0;
        int misses = 0;
        int writes = 0;

        // Write to cache
        function void write(addr_t address, data_t data);
            cache[address] = data;
            writes++;
            $display("[%0t] WRITE: Addr=0x%h, Data=0x%h",
                     $time, address, data);
        endfunction

        // Read from cache
        function data_t read(addr_t address, output bit hit);
            if (cache.exists(address)) begin
                hits++;
                hit = 1;
                $display("[%0t] READ HIT: Addr=0x%h, Data=0x%h",
                         $time, address, cache[address]);
                return cache[address];
            end else begin
                misses++;
                hit = 0;
                $display("[%0t] READ MISS: Addr=0x%h",
                         $time, address);
                return 32'hXXXXXXXX;
            end
        endfunction

        // Invalidate cache line
        function void invalidate(addr_t address);
            if (cache.exists(address)) begin
                cache.delete(address);
                $display("[%0t] INVALIDATE: Addr=0x%h", $time, address);
            end
        endfunction

        // Flush entire cache
        function void flush();
            int num_lines = cache.num();
            cache.delete();
            $display("[%0t] FLUSH: Cleared %0d cache lines", $time, num_lines);
        endfunction

        // Display statistics
        function void display_stats();
            real hit_rate = (hits + misses > 0) ?
                            (real'(hits) / (hits + misses)) * 100.0 : 0.0;

            $display("\n=== Cache Statistics ===");
            $display("Total Lines: %0d", cache.num());
            $display("Reads - Hits: %0d, Misses: %0d", hits, misses);
            $display("Hit Rate: %0.2f%%", hit_rate);
            $display("Writes: %0d", writes);
        endfunction

        // Display cache contents
        function void display_contents();
            addr_t addr;
            $display("\n=== Cache Contents ===");
            if (cache.num() == 0) begin
                $display("  (empty)");
                return;
            end

            if (cache.first(addr)) begin
                do begin
                    $display("  [0x%h] = 0x%h", addr, cache[addr]);
                end while (cache.next(addr));
            end
        endfunction
    endclass

    initial begin
        CacheMemory cache = new();
        bit hit;

        // Test sequence
        cache.write(32'h1000, 32'hAAAA);
        cache.write(32'h2000, 32'hBBBB);
        cache.write(32'h3000, 32'hCCCC);

        #10;
        void'(cache.read(32'h1000, hit));  // Hit
        void'(cache.read(32'h2000, hit));  // Hit
        void'(cache.read(32'h4000, hit));  // Miss

        cache.write(32'h4000, 32'hDDDD);
        void'(cache.read(32'h4000, hit));  // Hit now

        cache.display_contents();

        cache.invalidate(32'h2000);
        void'(cache.read(32'h2000, hit));  // Miss after invalidate

        cache.display_contents();
        cache.display_stats();
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 31: Symbol Table}

Implement a symbol table using associative arrays:
\begin{itemize}
  \item Use string keys for symbol names
  \item Store: value, type (int/real/string), scope level
  \item Function \texttt{insert\_symbol(name, value, type, scope)}
  \item Function \texttt{lookup\_symbol(name)} - returns symbol info
  \item Function \texttt{delete\_scope(scope\_level)} - remove all symbols at scope
  \item Function \texttt{display\_table()} - show all symbols
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 32: Register Map}

Create a register map for a peripheral:
\begin{itemize}
  \item Associative array: address $\rightarrow$ register info (name, access type, reset value)
  \item Function \texttt{add\_register(addr, name, access, reset\_val)}
  \item Function \texttt{read\_register(addr)} - returns current value
  \item Function \texttt{write\_register(addr, data)} - writes if allowed
  \item Function \texttt{reset\_all()} - reset to default values
  \item Function \texttt{dump\_registers()} - display all
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Associative Arrays}

\begin{quizbox}
\textbf{Quiz 7: Associative Arrays}

\begin{enumerate}
  \item How do you declare an associative array with string indices? \_\_\_\_\_\_\_\_\_\_\_\_
  \item What method checks if a specific index exists? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item How do you get the number of entries? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What's the advantage of associative arrays over dynamic arrays?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can you use structures as indices? (Yes/No) \_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{type name[string];}
  \item \texttt{exists(index)}
  \item \texttt{num()}
  \item Sparse storage, arbitrary index types, faster lookup for sparse data
  \item Yes (if packed)
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Interfaces and Modports}

\subsection{Introduction to Interfaces}

Interfaces encapsulate connectivity and communication protocols, making designs more modular and easier to maintain.

\begin{lstlisting}[caption={Basic Interface Example}]
// Simple interface definition
interface simple_bus;
    logic [7:0] data;
    logic       valid;
    logic       ready;
endinterface

// Module using interface
module producer(simple_bus bus, input logic clk);
    always @(posedge clk) begin
        bus.data <= $random;
        bus.valid <= 1'b1;
    end
endmodule

module consumer(simple_bus bus, input logic clk);
    always @(posedge clk) begin
        if (bus.valid && bus.ready) begin
            $display("[%0t] Received data: 0x%h", $time, bus.data);
        end
    end
endmodule

// Top-level connection
module top;
    logic clk;

    // Instantiate interface
    simple_bus bus();

    // Connect modules through interface
    producer prod(.bus(bus), .clk(clk));
    consumer cons(.bus(bus), .clk(clk));

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    initial begin
        bus.ready = 1'b1;
        #100 $finish;
    end
endmodule
\end{lstlisting}

\subsection{Interfaces with Clocking Blocks}

\begin{lstlisting}[caption={Interface with Clocking Block}]
interface apb_if(input logic pclk);
    logic [31:0] paddr;
    logic        psel;
    logic        penable;
    logic        pwrite;
    logic [31:0] pwdata;
    logic [31:0] prdata;
    logic        pready;
    logic        pslverr;

    // Clocking block for master
    clocking master_cb @(posedge pclk);
        output paddr;
        output psel;
        output penable;
        output pwrite;
        output pwdata;
        input  prdata;
        input  pready;
        input  pslverr;
    endclocking

    // Clocking block for slave
    clocking slave_cb @(posedge pclk);
        input  paddr;
        input  psel;
        input  penable;
        input  pwrite;
        input  pwdata;
        output prdata;
        output pready;
        output pslverr;
    endclocking

    // Clocking block for monitor
    clocking monitor_cb @(posedge pclk);
        input paddr;
        input psel;
        input penable;
        input pwrite;
        input pwdata;
        input prdata;
        input pready;
        input pslverr;
    endclocking

endinterface
\end{lstlisting}

\subsection{Modports}

Modports restrict interface access from different modules, improving encapsulation.

\begin{lstlisting}[caption={Interface with Modports}]
interface axi_stream_if(input logic clk, input logic rst_n);
    logic [31:0] tdata;
    logic [3:0]  tkeep;
    logic        tvalid;
    logic        tready;
    logic        tlast;

    // Master modport - can drive tdata, tvalid, tlast
    modport master (
        input  clk,
        input  rst_n,
        output tdata,
        output tkeep,
        output tvalid,
        input  tready,
        output tlast
    );

    // Slave modport - can drive tready
    modport slave (
        input  clk,
        input  rst_n,
        input  tdata,
        input  tkeep,
        input  tvalid,
        output tready,
        input  tlast
    );

    // Monitor modport - can only read
    modport monitor (
        input clk,
        input rst_n,
        input tdata,
        input tkeep,
        input tvalid,
        input tready,
        input tlast
    );

endinterface

// Master module
module axi_stream_master(axi_stream_if.master bus);
    int count = 0;

    always @(posedge bus.clk or negedge bus.rst_n) begin
        if (!bus.rst_n) begin
            bus.tdata <= 32'h0;
            bus.tkeep <= 4'h0;
            bus.tvalid <= 1'b0;
            bus.tlast <= 1'b0;
            count <= 0;
        end else begin
            if (bus.tready || !bus.tvalid) begin
                bus.tdata <= count;
                bus.tkeep <= 4'hF;
                bus.tvalid <= 1'b1;
                bus.tlast <= (count == 15);
                count <= (count == 15) ? 0 : count + 1;
            end
        end
    end
endmodule

// Slave module
module axi_stream_slave(axi_stream_if.slave bus);
    always @(posedge bus.clk or negedge bus.rst_n) begin
        if (!bus.rst_n) begin
            bus.tready <= 1'b0;
        end else begin
            bus.tready <= 1'b1;  // Always ready in this simple example

            if (bus.tvalid && bus.tready) begin
                $display("[%0t] Received: tdata=0x%h, tlast=%b",
                         $time, bus.tdata, bus.tlast);
            end
        end
    end
endmodule

// Monitor module
module axi_stream_monitor(axi_stream_if.monitor bus);
    int packet_count = 0;
    int transfer_count = 0;

    always @(posedge bus.clk) begin
        if (bus.tvalid && bus.tready) begin
            transfer_count++;
            $display("[MONITOR] Transfer %0d: Data=0x%h, Last=%b",
                     transfer_count, bus.tdata, bus.tlast);

            if (bus.tlast) begin
                packet_count++;
                $display("[MONITOR] Packet %0d complete (%0d transfers)",
                         packet_count, transfer_count);
                transfer_count = 0;
            end
        end
    end
endmodule

// Top module connecting everything
module axi_stream_system;
    logic clk, rst_n;

    // Instantiate interface
    axi_stream_if axis_if(clk, rst_n);

    // Instantiate modules with modports
    axi_stream_master master(.bus(axis_if.master));
    axi_stream_slave  slave(.bus(axis_if.slave));
    axi_stream_monitor monitor(.bus(axis_if.monitor));

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // Reset and simulation control
    initial begin
        rst_n = 0;
        #20 rst_n = 1;
        #500 $finish;
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 33: UART Interface}

Create a UART interface with:
\begin{itemize}
  \item Signals: tx, rx, cts, rts
  \item Clocking block for synchronous sampling
  \item Modports: transmitter, receiver, monitor
  \item Methods: \texttt{task send\_byte(byte data)}, \texttt{task receive\_byte(output byte data)}
\end{itemize}

Instantiate transmitter and receiver modules using the modports.
\end{exercisebox}

\subsection{Interface Methods and Tasks}

Interfaces can contain tasks and functions for protocol-specific operations.

\begin{lstlisting}[caption={Interface with Methods}]
interface wishbone_if(input logic clk, input logic rst);
    logic [31:0] adr;
    logic [31:0] dat_o;  // Data output (master to slave)
    logic [31:0] dat_i;  // Data input (slave to master)
    logic        we;
    logic        stb;
    logic        cyc;
    logic        ack;

    // Modports
    modport master (
        output adr, dat_o, we, stb, cyc,
        input  dat_i, ack,
        import write, read
    );

    modport slave (
        input  adr, dat_o, we, stb, cyc,
        output dat_i, ack
    );

    // Write transaction task
    task automatic write(input logic [31:0] address, input logic [31:0] data);
        @(posedge clk);
        adr <= address;
        dat_o <= data;
        we <= 1'b1;
        stb <= 1'b1;
        cyc <= 1'b1;

        @(posedge clk);
        while (!ack) @(posedge clk);

        stb <= 1'b0;
        cyc <= 1'b0;
        we <= 1'b0;

        $display("[%0t] WB Write: Addr=0x%h, Data=0x%h", $time, address, data);
    endtask

    // Read transaction task
    task automatic read(input logic [31:0] address, output logic [31:0] data);
        @(posedge clk);
        adr <= address;
        we <= 1'b0;
        stb <= 1'b1;
        cyc <= 1'b1;

        @(posedge clk);
        while (!ack) @(posedge clk);

        data = dat_i;
        stb <= 1'b0;
        cyc <= 1'b0;

        $display("[%0t] WB Read: Addr=0x%h, Data=0x%h", $time, address, data);
    endtask

endinterface

// Example usage
module wishbone_master_example(wishbone_if.master bus);
    initial begin
        logic [31:0] read_data;

        // Wait for reset
        @(posedge bus.clk);

        // Perform write
        bus.write(32'h1000, 32'hAABBCCDD);

        // Perform read
        bus.read(32'h1000, read_data);

        $display("Read back: 0x%h", read_data);
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 34: SPI Interface}

Design an SPI interface with:
\begin{itemize}
  \item Signals: sclk, mosi, miso, cs\_n
  \item Modports: master, slave, monitor
  \item Task \texttt{transfer(input [7:0] tx\_data, output [7:0] rx\_data)} in interface
  \item Support for CPOL=0, CPHA=0 mode
  \item Test with master sending data to slave
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Interfaces}

\begin{quizbox}
\textbf{Quiz 8: Interfaces and Modports}

\begin{enumerate}
  \item What keyword is used to define an interface? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What is the purpose of modports? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can interfaces contain tasks and functions? (Yes/No) \_\_\_\_\_\_
  \item What keyword creates synchronized sampling in interfaces? \_\_\_\_\_\_\_\_\_\_
  \item How do you import a task from an interface into a modport? \_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{interface}
  \item To restrict and control access to interface signals from different modules
  \item Yes
  \item \texttt{clocking}
  \item Use \texttt{import task\_name} in the modport declaration
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Virtual Interfaces}

\subsection{Why Virtual Interfaces?}

Virtual interfaces enable polymorphic behavior with interfaces, essential for verification environments.

\begin{lstlisting}[caption={Virtual Interface Basics}]
interface simple_if;
    logic [7:0] data;
    logic       valid;
endinterface

class Driver;
    virtual simple_if vif;  // Virtual interface handle

    function new(virtual simple_if vif);
        this.vif = vif;
    endfunction

    task drive(logic [7:0] value);
        vif.data = value;
        vif.valid = 1'b1;
        $display("[%0t] Driver: Driving 0x%h", $time, value);
    endtask
endclass

module virtual_interface_example;
    simple_if sif();  // Instantiate interface

    initial begin
        Driver drv;
        drv = new(sif);  // Pass interface to class

        #10 drv.drive(8'hAA);
        #10 drv.drive(8'hBB);
        #10 drv.drive(8'hCC);
    end
endmodule
\end{lstlisting}

\subsection{Practical Verification Example}

\begin{lstlisting}[caption={Complete Verification Environment with Virtual Interfaces}]
// Interface definition
interface axi_lite_if(input logic clk);
    logic [31:0] awaddr;
    logic        awvalid;
    logic        awready;
    logic [31:0] wdata;
    logic        wvalid;
    logic        wready;
    logic [1:0]  bresp;
    logic        bvalid;
    logic        bready;
    logic [31:0] araddr;
    logic        arvalid;
    logic        arready;
    logic [31:0] rdata;
    logic [1:0]  rresp;
    logic        rvalid;
    logic        rready;
endinterface

// Transaction class
class axi_transaction;
    rand logic [31:0] address;
    rand logic [31:0] data;
    rand bit          write;  // 1=write, 0=read

    function void display(string prefix = "");
        $display("%s AXI Transaction: %s Addr=0x%h Data=0x%h",
                 prefix, write ? "WRITE" : "READ", address, data);
    endfunction
endclass

// Driver class
class axi_driver;
    virtual axi_lite_if.master vif;

    function new(virtual axi_lite_if.master vif);
        this.vif = vif;
    endfunction

    task reset();
        vif.awvalid <= 0;
        vif.wvalid <= 0;
        vif.bready <= 0;
        vif.arvalid <= 0;
        vif.rready <= 0;
    endtask

    task write(axi_transaction trans);
        // Address phase
        @(posedge vif.clk);
        vif.awaddr <= trans.address;
        vif.awvalid <= 1'b1;

        @(posedge vif.clk);
        while (!vif.awready) @(posedge vif.clk);
        vif.awvalid <= 1'b0;

        // Data phase
        vif.wdata <= trans.data;
        vif.wvalid <= 1'b1;

        @(posedge vif.clk);
        while (!vif.wready) @(posedge vif.clk);
        vif.wvalid <= 1'b0;

        // Response
        vif.bready <= 1'b1;
        @(posedge vif.clk);
        while (!vif.bvalid) @(posedge vif.clk);
        vif.bready <= 1'b0;

        trans.display("[DRIVER]");
    endtask

    task read(axi_transaction trans);
        // Address phase
        @(posedge vif.clk);
        vif.araddr <= trans.address;
        vif.arvalid <= 1'b1;

        @(posedge vif.clk);
        while (!vif.arready) @(posedge vif.clk);
        vif.arvalid <= 1'b0;

        // Data phase
        vif.rready <= 1'b1;
        @(posedge vif.clk);
        while (!vif.rvalid) @(posedge vif.clk);
        trans.data = vif.rdata;
        vif.rready <= 1'b0;

        trans.display("[DRIVER]");
    endtask
endclass

// Monitor class
class axi_monitor;
    virtual axi_lite_if.monitor vif;
    mailbox #(axi_transaction) mon2scb;

    function new(virtual axi_lite_if.monitor vif, mailbox #(axi_transaction) mon2scb);
        this.vif = vif;
        this.mon2scb = mon2scb;
    endfunction

    task run();
        axi_transaction trans;

        forever begin
            @(posedge vif.clk);

            // Detect write transaction
            if (vif.awvalid && vif.awready) begin
                trans = new();
                trans.write = 1;
                trans.address = vif.awaddr;

                // Wait for data
                @(posedge vif.clk);
                while (!(vif.wvalid && vif.wready)) @(posedge vif.clk);
                trans.data = vif.wdata;

                trans.display("[MONITOR]");
                mon2scb.put(trans);
            end

            // Detect read transaction
            if (vif.arvalid && vif.arready) begin
                trans = new();
                trans.write = 0;
                trans.address = vif.araddr;

                // Wait for data
                @(posedge vif.clk);
                while (!(vif.rvalid && vif.rready)) @(posedge vif.clk);
                trans.data = vif.rdata;

                trans.display("[MONITOR]");
                mon2scb.put(trans);
            end
        end
    endtask
endclass

// Scoreboard class
class scoreboard;
    mailbox #(axi_transaction) mon2scb;
    axi_transaction expected_q[$];
    int matches = 0;
    int mismatches = 0;

    function new(mailbox #(axi_transaction) mon2scb);
        this.mon2scb = mon2scb;
    endfunction

    task run();
        axi_transaction act_trans;

        forever begin
            mon2scb.get(act_trans);

            if (expected_q.size() > 0) begin
                axi_transaction exp_trans = expected_q.pop_front();

                if (exp_trans.address == act_trans.address &&
                    exp_trans.data == act_trans.data &&
                    exp_trans.write == act_trans.write) begin
                    matches++;
                    $display("[SCOREBOARD] MATCH!");
                end else begin
                    mismatches++;
                    $display("[SCOREBOARD] MISMATCH!");
                    exp_trans.display("  Expected:");
                    act_trans.display("  Actual:");
                end
            end
        end
    endtask

    function void add_expected(axi_transaction trans);
        expected_q.push_back(trans);
    endfunction

    function void report();
        $display("\n=== SCOREBOARD REPORT ===");
        $display("Matches: %0d", matches);
        $display("Mismatches: %0d", mismatches);
        if (mismatches == 0)
            $display("TEST PASSED!");
        else
            $display("TEST FAILED!");
    endfunction
endclass

// Environment class
class environment;
    virtual axi_lite_if.master vif_master;
    virtual axi_lite_if.monitor vif_monitor;

    axi_driver    driver;
    axi_monitor   monitor;
    scoreboard    scb;
    mailbox #(axi_transaction) mon2scb;

    function new(virtual axi_lite_if.master vif_m, virtual axi_lite_if.monitor vif_mon);
        this.vif_master = vif_m;
        this.vif_monitor = vif_mon;

        mon2scb = new();
        driver = new(vif_master);
        monitor = new(vif_monitor, mon2scb);
        scb = new(mon2scb);
    endfunction

    task run();
        fork
            monitor.run();
            scb.run();
        join_none
    endtask
endclass
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 35: I2C Verification Environment}

Create a verification environment for I2C:
\begin{itemize}
  \item Define I2C interface (scl, sda)
  \item Transaction class (address, data, read/write)
  \item Driver class with virtual interface
  \item Monitor class
  \item Scoreboard
  \item Environment to integrate all components
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 36: Configurable Driver}

Create a configurable driver using virtual interfaces:
\begin{itemize}
  \item Support multiple interface types (APB, AHB, AXI)
  \item Use base class with virtual interface
  \item Derived classes for each protocol
  \item Configuration class to select driver type
  \item Test with different protocols
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Virtual Interfaces}

\begin{quizbox}
\textbf{Quiz 9: Virtual Interfaces}

\begin{enumerate}
  \item What keyword makes an interface handle polymorphic? \_\_\_\_\_\_\_\_\_\_\_\_
  \item Why are virtual interfaces necessary in classes? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can you reassign a virtual interface to point to different interface instances? (Yes/No) \_\_\_\_
  \item Where are virtual interfaces typically used?\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can virtual interfaces be passed as function/task arguments? (Yes/No) \_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{virtual}
  \item Classes cannot directly contain interface instances; virtual interfaces provide a handle/pointer to interface instances
  \item Yes
  \item Verification environments, testbenches, UVM components
  \item Yes
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Packages and Import}

\subsection{Creating Packages}

Packages group related declarations for reuse across multiple modules.

\begin{lstlisting}[caption={Basic Package}]
package math_pkg;
    // Constants
    parameter real PI = 3.14159265359;
    parameter real E = 2.71828182846;

    // Typedef
    typedef real radians_t;
    typedef real degrees_t;

    // Functions
    function radians_t deg_to_rad(degrees_t deg);
        return deg * PI / 180.0;
    endfunction

    function degrees_t rad_to_deg(radians_t rad);
        return rad * 180.0 / PI;
    endfunction

    function real power(real base, int exp);
        real result = 1.0;
        for (int i = 0; i < exp; i++)
            result *= base;
        return result;
    endfunction
endpackage

// Using the package
module package_user;
    import math_pkg::*;  // Import all

    initial begin
        real angle_deg = 90.0;
        real angle_rad;

        angle_rad = deg_to_rad(angle_deg);
        $display("90 degrees = %0.4f radians", angle_rad);
        $display("PI = %0.10f", PI);
        $display("2^10 = %0.0f", power(2.0, 10));
    end
endmodule
\end{lstlisting}

\subsection{Package Best Practices}

\begin{lstlisting}[caption={Well-Organized Package}]
package axi_pkg;
    // Constants
    parameter int ADDR_WIDTH = 32;
    parameter int DATA_WIDTH = 32;
    parameter int ID_WIDTH = 4;

    // Enumerations
    typedef enum logic [1:0] {
        RESP_OKAY   = 2'b00,
        RESP_EXOKAY = 2'b01,
        RESP_SLVERR = 2'b10,
        RESP_DECERR = 2'b11
    } axi_resp_t;

    typedef enum logic [2:0] {
        BURST_FIXED = 3'b000,
        BURST_INCR  = 3'b001,
        BURST_WRAP  = 3'b010
    } axi_burst_t;

    typedef enum logic [1:0] {
        SIZE_1BYTE  = 2'b00,
        SIZE_2BYTES = 2'b01,
        SIZE_4BYTES = 2'b10,
        SIZE_8BYTES = 2'b11
    } axi_size_t;

    // Structures
    typedef struct packed {
        logic [ID_WIDTH-1:0]   id;
        logic [ADDR_WIDTH-1:0] addr;
        logic [7:0]            len;
        axi_size_t             size;
        axi_burst_t            burst;
    } axi_addr_t;

    typedef struct packed {
        logic [DATA_WIDTH-1:0]     data;
        logic [(DATA_WIDTH/8)-1:0] strb;
        logic                      last;
    } axi_data_t;

    typedef struct packed {
        logic [ID_WIDTH-1:0] id;
        axi_resp_t           resp;
    } axi_resp_pkt_t;

    // Transaction class
    class AXI_Transaction;
        rand logic [ADDR_WIDTH-1:0] address;
        rand logic [DATA_WIDTH-1:0] data[];
        rand int                    length;
        rand bit                    write;
        axi_resp_t                  response;

        constraint reasonable_length {
            length inside {[1:16]};
        }

        constraint valid_data_size {
            data.size() == length;
        }

        function new();
            data = new[1];
        endfunction

        function void display(string prefix = "");
            $display("%s %s Transaction:", prefix, write ? "WRITE" : "READ");
            $display("  Address: 0x%h", address);
            $display("  Length: %0d", length);
            $display("  Data: %p", data);
        endfunction

        function AXI_Transaction copy();
            AXI_Transaction trans = new();
            trans.address = this.address;
            trans.length = this.length;
            trans.write = this.write;
            trans.response = this.response;
            trans.data = new[this.data.size()];
            foreach(this.data[i])
                trans.data[i] = this.data[i];
            return trans;
        endfunction
    endclass

    // Utility functions
    function string resp_to_string(axi_resp_t resp);
        case (resp)
            RESP_OKAY:   return "OKAY";
            RESP_EXOKAY: return "EXOKAY";
            RESP_SLVERR: return "SLVERR";
            RESP_DECERR: return "DECERR";
        endcase
    endfunction

    function bit is_aligned(logic [ADDR_WIDTH-1:0] addr, axi_size_t size);
        case (size)
            SIZE_1BYTE:  return 1'b1;
            SIZE_2BYTES: return (addr[0] == 0);
            SIZE_4BYTES: return (addr[1:0] == 0);
            SIZE_8BYTES: return (addr[2:0] == 0);
        endcase
    endfunction

endpackage : axi_pkg

// Using the package
module axi_test;
    import axi_pkg::*;

    initial begin
        AXI_Transaction trans;
        trans = new();

        assert(trans.randomize()) else $fatal("Randomization failed");
        trans.display("[TEST]");

        $display("Response: %s", resp_to_string(RESP_OKAY));
        $display("Is 0x100 aligned for 4-byte access? %b",
                 is_aligned(32'h100, SIZE_4BYTES));
    end
endmodule
\end{lstlisting}

\subsection{Selective Import}

\begin{lstlisting}[caption={Import Specific Items}]
package utilities_pkg;
    // Many definitions...
    function int add(int a, int b);
        return a + b;
    endfunction

    function int multiply(int a, int b);
        return a * b;
    endfunction

    parameter int MAX_SIZE = 1024;
    parameter int MIN_SIZE = 1;
endpackage

module selective_import_example;
    // Import only specific items
    import utilities_pkg::add;
    import utilities_pkg::MAX_SIZE;
    // multiply and MIN_SIZE are not imported

    initial begin
        $display("Sum: %0d", add(5, 3));
        $display("Max size: %0d", MAX_SIZE);

        // This would cause error: multiply not imported
        // $display("Product: %0d", multiply(5, 3));
    end
endmodule

module wildcard_import_example;
    // Import everything
    import utilities_pkg::*;

    initial begin
        $display("Sum: %0d", add(5, 3));
        $display("Product: %0d", multiply(5, 3));
        $display("Max: %0d, Min: %0d", MAX_SIZE, MIN_SIZE);
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 37: Protocol Package}

Create a complete protocol package for UART:
\begin{itemize}
  \item Constants: baud rates, data bits, parity options
  \item Enumerations: parity type, stop bits
  \item Structure: UART frame (data, parity, etc.)
  \item Transaction class
  \item Utility functions: calculate parity, encode frame
  \item Test module using the package
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 38: Verification Component Package}

Create a package for verification components:
\begin{itemize}
  \item Base transaction class
  \item Driver base class
  \item Monitor base class
  \item Scoreboard base class
  \item Common utility functions
  \item Use in a simple verification environment
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Packages}

\begin{quizbox}
\textbf{Quiz 10: Packages and Import}

\begin{enumerate}
  \item How do you import all items from a package? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item How do you import only specific items? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can packages contain classes? (Yes/No) \_\_\_\_\_\_
  \item What happens if two imported packages define the same identifier?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can packages be nested (package inside package)? (Yes/No) \_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{import package\_name::*;}
  \item \texttt{import package\_name::item1, package\_name::item2;}
  \item Yes
  \item Compilation error (ambiguity); use explicit package::item qualification
  \item No
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Object-Oriented Programming Basics}

\subsection{Classes and Objects}

\begin{lstlisting}[caption={Basic Class Definition}]
class Counter;
    // Properties (member variables)
    int count;
    string name;

    // Constructor
    function new(string n = "Counter", int initial_value = 0);
        name = n;
        count = initial_value;
        $display("Created %s with initial value %0d", name, count);
    endfunction

    // Methods
    function void increment();
        count++;
        $display("%s: incremented to %0d", name, count);
    endfunction

    function void decrement();
        count--;
        $display("%s: decremented to %0d", name, count);
    endfunction

    function void reset();
        count = 0;
        $display("%s: reset to 0", name);
    endfunction

    function int get_value();
        return count;
    endfunction

    function void display();
        $display("Counter '%s' = %0d", name, count);
    endfunction
endclass

module oop_basics;
    initial begin
        Counter c1, c2;

        // Create objects
        c1 = new("Counter1", 10);
        c2 = new("Counter2");

        // Use methods
        c1.increment();
        c1.increment();
        c1.display();

        c2.increment();
        c2.increment();
        c2.increment();
        c2.display();

        c1.reset();
        c1.display();
    end
endmodule
\end{lstlisting}

\subsection{Encapsulation with Local and Protected}

\begin{lstlisting}[caption={Data Hiding and Encapsulation}]
class BankAccount;
    local real balance;        // Private to this class
    protected string owner;    // Accessible in derived classes
    int account_number;        // Public

    function new(string owner_name, int acc_num, real initial_balance = 0);
        owner = owner_name;
        account_number = acc_num;
        balance = initial_balance;
    endfunction

    // Public interface
    function bit deposit(real amount);
        if (amount <= 0) begin
            $error("Invalid deposit amount: %0.2f", amount);
            return 0;
        end
        balance += amount;
        $display("Deposited $%0.2f. New balance: $%0.2f", amount, balance);
        return 1;
    endfunction

    function bit withdraw(real amount);
        if (amount <= 0) begin
            $error("Invalid withdrawal amount");
            return 0;
        end
        if (amount > balance) begin
            $error("Insufficient funds");
            return 0;
        end
        balance -= amount;
        $display("Withdrew $%0.2f. New balance: $%0.2f", amount, balance);
        return 1;
    endfunction

    function real get_balance();
        return balance;
    endfunction

    function void display_info();
        $display("Account: %0d, Owner: %s, Balance: $%0.2f",
                 account_number, owner, balance);
    endfunction
endclass

module encapsulation_example;
    initial begin
        BankAccount acc;
        acc = new("John Doe", 12345, 1000.0);

        acc.display_info();
        void'(acc.deposit(500.0));
        void'(acc.withdraw(200.0));
        void'(acc.withdraw(2000.0));  // Should fail

        $display("Final balance: $%0.2f", acc.get_balance());

        // This would cause error - balance is local:
        // acc.balance = 999999.99;
    end
endmodule
\end{lstlisting}

\subsection{Static Members}

\begin{lstlisting}[caption={Static Properties and Methods}]
class Employee;
    static int employee_count = 0;  // Shared across all instances
    static real total_salary = 0.0;

    int id;
    string name;
    real salary;

    function new(string emp_name, real emp_salary);
        employee_count++;
        id = employee_count;
        name = emp_name;
        salary = emp_salary;
        total_salary += salary;

        $display("Employee #%0d created: %s ($%0.2f/year)",
                 id, name, salary);
    endfunction

    // Static method
    static function void display_statistics();
        $display("\n=== Company Statistics ===");
        $display("Total Employees: %0d", employee_count);
        $display("Total Salary Budget: $%0.2f", total_salary);
        if (employee_count > 0)
            $display("Average Salary: $%0.2f", total_salary / employee_count);
    endfunction

    function void display();
        $display("ID: %0d, Name: %s, Salary: $%0.2f",
                 id, name, salary);
    endfunction
endclass

module static_members_example;
    initial begin
        Employee emp1, emp2, emp3;

        emp1 = new("Alice", 75000.0);
        emp2 = new("Bob", 82000.0);
        emp3 = new("Carol", 78000.0);

        emp1.display();
        emp2.display();
        emp3.display();

        Employee::display_statistics();  // Call static method
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 39: Library Management System}

Create a library management system with classes:
\begin{itemize}
  \item \texttt{Book} class: title, author, ISBN, available
  \item \texttt{Member} class: name, ID, books\_borrowed[]
  \item \texttt{Library} class: books[], members[], methods to borrow/return
  \item Static tracking of total books and members
  \item Methods: add book, register member, borrow, return, display
\end{itemize}
\end{exercisebox}

\subsection{Copy and Clone}

\begin{lstlisting}[caption={Deep Copy vs Shallow Copy}]
class Data;
    int value;
    int array[];

    function new(int v = 0, int size = 5);
        value = v;
        array = new[size];
        foreach(array[i]) array[i] = i;
    endfunction

    // Shallow copy (default assignment)
    // obj2 = obj1; // Both share same array!

    // Deep copy method
    function Data copy();
        Data new_obj = new(this.value, this.array.size());
        foreach(this.array[i])
            new_obj.array[i] = this.array[i];
        return new_obj;
    endfunction

    function void display(string name);
        $display("%s: value=%0d, array=%p", name, value, array);
    endfunction
endclass

module copy_example;
    initial begin
        Data obj1, obj2, obj3;

        obj1 = new(10, 3);
        obj1.array = '{1, 2, 3};
        obj1.display("obj1");

        // Shallow copy (handle copy)
        obj2 = obj1;  // obj2 points to same object as obj1!
        obj2.value = 20;
        obj2.array[0] = 100;

        $display("\nAfter shallow copy modification:");
        obj1.display("obj1");  // Also changed!
        obj2.display("obj2");

        // Deep copy
        obj1 = new(10, 3);
        obj1.array = '{1, 2, 3};
        obj3 = obj1.copy();  // Create new independent object

        obj3.value = 30;
        obj3.array[0] = 200;

        $display("\nAfter deep copy modification:");
        obj1.display("obj1");  // Unchanged
        obj3.display("obj3");  // Changed
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 40: Configuration Class with Deep Copy}

Create a test configuration class with:
\begin{itemize}
  \item Properties: timeout, verbosity, enabled\_tests[]
  \item Deep copy method
  \item Compare method to check equality
  \item Display method
  \item Test shallow vs deep copy behavior
\end{itemize}
\end{exercisebox}

\subsection{Quiz: OOP Basics}

\begin{quizbox}
\textbf{Quiz 11: Object-Oriented Programming Basics}

\begin{enumerate}
  \item What keyword defines a class? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What is the name of the class constructor method? \_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What access modifier restricts access to the current class only? \_\_\_\_\_\_\_\_\_\_
  \item Are static members shared across all instances? (Yes/No) \_\_\_\_\_\_
  \item What happens when you assign one object to another (obj2 = obj1)?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{class}
  \item \texttt{new}
  \item \texttt{local}
  \item Yes
  \item Shallow copy - obj2 becomes a handle to the same object as obj1
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Inheritance and Polymorphism}

\subsection{Basic Inheritance}

\begin{lstlisting}[caption={Inheritance Example}]
// Base class
class Vehicle;
    string brand;
    int year;
    real price;

    function new(string b, int y, real p);
        brand = b;
        year = y;
        price = p;
    endfunction

    virtual function void display();
        $display("Vehicle: %s (%0d) - $%0.2f", brand, year, price);
    endfunction

    virtual function real calculate_tax();
        return price * 0.05;  // 5% tax
    endfunction
endclass

// Derived class
class Car extends Vehicle;
    int num_doors;
    bit has_sunroof;

    function new(string b, int y, real p, int doors, bit sunroof);
        super.new(b, y, p);  // Call parent constructor
        num_doors = doors;
        has_sunroof = sunroof;
    endfunction

    // Override parent method
    virtual function void display();
        $display("Car: %s (%0d) - $%0.2f, %0d doors, Sunroof: %s",
                 brand, year, price, num_doors,
                 has_sunroof ? "Yes" : "No");
    endfunction

    // Override tax calculation
    virtual function real calculate_tax();
        real base_tax = super.calculate_tax();
        if (has_sunroof) base_tax += 500;  // Luxury tax
        return base_tax;
    endfunction
endclass

class Truck extends Vehicle;
    real cargo_capacity;  // in tons

    function new(string b, int y, real p, real capacity);
        super.new(b, y, p);
        cargo_capacity = capacity;
    endfunction

    virtual function void display();
        $display("Truck: %s (%0d) - $%0.2f, Capacity: %0.1f tons",
                 brand, year, price, cargo_capacity);
    endfunction

    virtual function real calculate_tax();
        return super.calculate_tax() + (cargo_capacity * 100);
    endfunction
endclass

module inheritance_example;
    initial begin
        Vehicle v;
        Car c;
        Truck t;

        c = new("Toyota", 2023, 25000.0, 4, 1);
        t = new("Ford", 2022, 45000.0, 5.0);

        c.display();
        $display("  Tax: $%0.2f", c.calculate_tax());

        t.display();
        $display("  Tax: $%0.2f", t.calculate_tax());

        // Polymorphism
        v = c;  // Base class handle to derived object
        v.display();  // Calls Car's display() due to virtual

        v = t;
        v.display();  // Calls Truck's display()
    end
endmodule
\end{lstlisting}

\subsection{Polymorphism in Practice}

\begin{lstlisting}[caption={Polymorphism Example}]
// Abstract base transaction
virtual class BaseTransaction;
    int id;
    realtime timestamp;

    function new(int trans_id);
        id = trans_id;
        timestamp = $realtime;
    endfunction

    pure virtual function void display();
    pure virtual function string get_type();
endclass

// Read transaction
class ReadTransaction extends BaseTransaction;
    bit [31:0] address;
    bit [31:0] data;

    function new(int trans_id, bit [31:0] addr);
        super.new(trans_id);
        address = addr;
        data = 0;
    endfunction

    virtual function void display();
        $display("[%0t] READ #%0d: Addr=0x%h, Data=0x%h",
                 timestamp, id, address, data);
    endfunction

    virtual function string get_type();
        return "READ";
    endfunction
endclass

// Write transaction
class WriteTransaction extends BaseTransaction;
    bit [31:0] address;
    bit [31:0] data;

    function new(int trans_id, bit [31:0] addr, bit [31:0] dat);
        super.new(trans_id);
        address = addr;
        data = dat;
    endfunction

    virtual function void display();
        $display("[%0t] WRITE #%0d: Addr=0x%h, Data=0x%h",
                 timestamp, id, address, data);
    endfunction

    virtual function string get_type();
        return "WRITE";
    endfunction
endclass

// Transaction processor
class TransactionProcessor;
    BaseTransaction trans_queue[$];

    function void add_transaction(BaseTransaction trans);
        trans_queue.push_back(trans);
        $display("Added %s transaction #%0d",
                 trans.get_type(), trans.id);
    endfunction

    task process_all();
        $display("\n=== Processing Transactions ===");
        foreach(trans_queue[i]) begin
            trans_queue[i].display();  // Polymorphic call
            #10;
        end
    endtask
endclass

module polymorphism_example;
    initial begin
        TransactionProcessor processor;
        ReadTransaction rd;
        WriteTransaction wr;

        processor = new();

        // Create and add different transaction types
        wr = new(1, 32'h1000, 32'hAAAA);
        processor.add_transaction(wr);

        rd = new(2, 32'h1000);
        processor.add_transaction(rd);

        wr = new(3, 32'h2000, 32'hBBBB);
        processor.add_transaction(wr);

        processor.process_all();
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 41: Network Protocol Stack}

Create a protocol hierarchy:
\begin{itemize}
  \item Base class \texttt{NetworkPacket}: virtual methods pack(), unpack(), display()
  \item \texttt{EthernetFrame extends NetworkPacket}: MAC addresses, EtherType
  \item \texttt{IPv4Packet extends EthernetFrame}: IP addresses, protocol
  \item \texttt{TCPPacket extends IPv4Packet}: ports, flags
  \item \texttt{UDPPacket extends IPv4Packet}: ports, checksum
  \item Test polymorphism with array of NetworkPacket handles
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Inheritance and Polymorphism}

\begin{quizbox}
\textbf{Quiz 12: Inheritance and Polymorphism}

\begin{enumerate}
  \item What keyword is used to inherit from a class? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item How do you call the parent class constructor? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What keyword makes a method polymorphic? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What is a pure virtual function? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item Can you instantiate an abstract class? (Yes/No) \_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{extends}
  \item \texttt{super.new()}
  \item \texttt{virtual}
  \item A function declared with \texttt{pure virtual} that must be overridden in derived classes
  \item No
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Advanced Verification Techniques}

\subsection{Constrained Random Verification}

\begin{lstlisting}[caption={Constrained Random Generation}]
class Transaction;
    rand bit [31:0] address;
    rand bit [31:0] data;
    rand bit [2:0]  burst_size;
    rand bit        write;

    // Constraints
    constraint address_range {
        address inside {[32'h0000:32'h0FFF], [32'h2000:32'h2FFF]};
    }

    constraint burst_constraint {
        burst_size inside {1, 2, 4, 8};
    }

    constraint write_distribution {
        write dist {1 := 70, 0 := 30};  // 70% writes, 30% reads
    end function

    function void display();
        $display("Trans: %s Addr=0x%h Data=0x%h Burst=%0d",
                 write ? "WR" : "RD", address, data, burst_size);
    endfunction
endclass

module constrained_random_example;
    initial begin
        Transaction trans;
        trans = new();

        $display("=== Generating 10 Random Transactions ===");
        repeat(10) begin
            assert(trans.randomize()) else $fatal("Randomization failed");
            trans.display();
        end
    end
endmodule
\end{lstlisting}

\subsection{Functional Coverage}

\begin{lstlisting}[caption={Functional Coverage Example}]
class CoverageCollector;
    bit [7:0] addr;
    bit [1:0] burst_type;
    bit       write;

    covergroup cg @(addr);
        address_cp: coverpoint addr {
            bins low    = {[0:63]};
            bins medium = {[64:127]};
            bins high   = {[128:255]};
        }

        burst_cp: coverpoint burst_type {
            bins single = {0};
            bins incr   = {1};
            bins wrap   = {2};
            illegal_bins illegal = {3};
        }

        write_cp: coverpoint write {
            bins read  = {0};
            bins write = {1};
        }

        // Cross coverage
        addr_x_burst: cross address_cp, burst_cp;
        addr_x_write: cross address_cp, write_cp;
    endgroup

    function new();
        cg = new();
    endfunction

    function void sample(bit [7:0] a, bit [1:0] b, bit w);
        addr = a;
        burst_type = b;
        write = w;
        // Sampling happens automatically at @(addr) event
    endfunction

    function void report();
        $display("Coverage: %0.2f%%", cg.get_coverage());
    endfunction
endclass
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 42: Complete Verification Environment}

Create a complete verification environment:
\begin{itemize}
  \item Transaction class with constraints
  \item Generator to create random transactions
  \item Driver with virtual interface
  \item Monitor to capture responses
  \item Scoreboard for checking
  \item Coverage collector
  \item Environment class integrating all
\end{itemize}
\end{exercisebox}

\subsection{Summary of Intermediate Level}

\begin{itemize}
    \item \textbf{Section 11}: Advanced data types and typedef
    \item \textbf{Section 12}: Dynamic arrays for flexible storage
    \item \textbf{Section 13}: Queues for FIFO/LIFO operations
    \item \textbf{Section 14}: Associative arrays for sparse data
    \item \textbf{Section 15}: Interfaces and modports for modular design
    \item \textbf{Section 16}: Virtual interfaces for verification
    \item \textbf{Section 17}: Packages for code organization
    \item \textbf{Section 18}: OOP basics with classes and objects
    \item \textbf{Section 19}: Inheritance and polymorphism
    \item \textbf{Section 20}: Verification techniques
\end{itemize}

\vfill
\begin{center}
\rule{0.6\textwidth}{0.4pt}\\
\Large\textbf{Intermediate Level Complete!}\\
\normalsize
\vspace{0.3cm}
You've mastered dynamic data structures, interfaces, packages,\\
and object-oriented programming in SystemVerilog.\\
\vspace{0.5cm}
\textit{Advancing to Expert Level - Sections 21-30...}\\
\end{center}

\newpage
% ============================================================================
% ADVANCED LEVEL - SECTIONS 21-30
% ============================================================================

\part{Advanced Level (Sections 21-30)}

\textit{Master professional verification techniques, UVM methodology, assertions, and industry best practices. This section represents expert-level SystemVerilog knowledge required for senior verification engineer positions.}

% ============================================================================
\section{SystemVerilog Assertions (SVA)}

\subsection{Introduction to Assertions}

SystemVerilog Assertions provide a powerful mechanism for specifying and verifying temporal behavior and protocol compliance. Assertions are essential for:
\begin{itemize}
  \item Protocol verification (AXI, APB, AHB, etc.)
  \item Interface checking
  \item Temporal property verification
  \item Functional coverage
  \item Formal verification
\end{itemize}

\begin{lstlisting}[caption={Immediate vs Concurrent Assertions}]
module assertion_basics(
    input logic clk,
    input logic rst_n,
    input logic req,
    input logic ack,
    input logic [7:0] data
);

    // Immediate assertion (procedural, executes like regular code)
    always @(posedge clk) begin
        if (req && rst_n) begin
            assert (data != 8'h00)
                else $error("Data cannot be zero when req is high");

            // With custom message
            assert (data < 8'hFF)
                else $error("[%0t] Data %h exceeds maximum", $time, data);
        end
    end

    // Concurrent assertion (declarative, continuously checked)
    property req_ack_handshake;
        @(posedge clk) disable iff (!rst_n)
        req |-> ##[1:3] ack;  // ack must follow req within 1-3 cycles
    endproperty

    assert property (req_ack_handshake)
        else $error("[%0t] Request not acknowledged within 3 cycles", $time);

    // Assertion with success and failure actions
    assert property (req_ack_handshake)
        $display("[%0t] Handshake completed successfully", $time);
        else $error("[%0t] Handshake failed", $time);

    // Assume for formal verification
    assume property (@(posedge clk) disable iff (!rst_n) req |-> data != 0);

    // Cover to track interesting events
    cover property (@(posedge clk) disable iff (!rst_n) req ##1 ack);

endmodule
\end{lstlisting}

\subsection{Sequence Operators and Temporal Logic}

SVA provides rich temporal operators for describing complex timing relationships:

\begin{lstlisting}[caption={Comprehensive Sequence Operators}]
module sva_sequences(
    input logic clk,
    input logic rst_n,
    input logic start,
    input logic busy,
    input logic done,
    input logic valid,
    input logic ready,
    input logic [3:0] state
);

    // ========== Delay Operators ==========

    // Fixed delay: ## operator
    property fixed_delay;
        @(posedge clk) disable iff (!rst_n)
        start |-> ##3 done;  // done exactly 3 cycles after start
    endproperty

    // Range delay
    property delay_range;
        @(posedge clk) disable iff (!rst_n)
        start |-> ##[1:5] done;  // done between 1 and 5 cycles
    endproperty

    // Unbounded delay
    property unbounded_delay;
        @(posedge clk) disable iff (!rst_n)
        start |-> ##[1:$] done;  // done eventually (at least 1 cycle)
    endproperty

    // ========== Repetition Operators ==========

    // Consecutive repetition [*n]
    property consecutive_repetition;
        @(posedge clk) disable iff (!rst_n)
        start |-> busy[*3] ##1 done;  // busy for exactly 3 cycles, then done
    endproperty

    // Range repetition
    property range_repetition;
        @(posedge clk) disable iff (!rst_n)
        start |-> busy[*1:5] ##1 done;  // busy for 1 to 5 cycles
    endproperty

    // Zero or more repetition
    property zero_or_more;
        @(posedge clk) disable iff (!rst_n)
        start |-> busy[*0:$] ##1 done;  // busy for any number of cycles
    endproperty

    // Non-consecutive repetition [=n]
    property non_consecutive_rep;
        @(posedge clk) disable iff (!rst_n)
        start |-> busy[=3] ##1 done;
        // busy is high 3 times (not necessarily consecutive), then done next cycle
    endproperty

    // Goto repetition [->n]
    property goto_rep;
        @(posedge clk) disable iff (!rst_n)
        start |-> busy[->3] ##1 done;
        // On 3rd occurrence of busy, done must be high next cycle
    endproperty

    // ========== Sequence Composition ==========

    // throughout operator (value must hold throughout sequence)
    property throughout_example;
        @(posedge clk) disable iff (!rst_n)
        start |-> (busy throughout (##[1:10] done));
        // busy must remain high until done occurs (1-10 cycles)
    endproperty

    // within operator
    property within_example;
        @(posedge clk) disable iff (!rst_n)
        start |-> ((valid && ready) within (##[1:5] done));
        // valid&&ready must occur before done (within 1-5 cycles of start)
    endproperty

    // intersect operator
    sequence seq1;
        valid ##[1:3] ready;
    endsequence

    sequence seq2;
        ##2 done;
    endsequence

    property intersect_example;
        @(posedge clk) disable iff (!rst_n)
        start |-> (seq1 intersect seq2);
        // Both sequences must complete at the same time
    endproperty

    // and operator for sequences
    property sequence_and;
        @(posedge clk) disable iff (!rst_n)
        (start ##1 busy) and (valid ##1 ready);
    endproperty

    // or operator for sequences
    property sequence_or;
        @(posedge clk) disable iff (!rst_n)
        start |-> (busy ##1 done) or (valid ##1 ready);
    endproperty

    // first_match - stops at first match
    property first_match_example;
        @(posedge clk) disable iff (!rst_n)
        start |-> first_match(busy[*1:$] ##1 done);
    endproperty

    // Instantiate some assertions
    assert property (fixed_delay);
    assert property (consecutive_repetition);
    assert property (throughout_example);
    assert property (goto_rep);

endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 48: FIFO Assertions with SVA}

Create comprehensive SVA assertions for a FIFO interface:
\begin{itemize}
  \item Assert read when empty produces error
  \item Assert write when full produces error
  \item Assert full and empty are mutually exclusive
  \item Assert count increments on write and decrements on read
  \item Assert data stability when valid
  \item Add coverage for corner cases (full, empty, simultaneous read/write)
\end{itemize}
\end{exercisebox}

\subsection{Real-World Protocol Assertions: AXI4}

\begin{lstlisting}[caption={Comprehensive AXI4-Lite Protocol Assertions}, basicstyle=\ttfamily\footnotesize]
module axi4_lite_assertions(
    input logic aclk,
    input logic aresetn,
    // Write address channel
    input logic [31:0] awaddr,
    input logic [2:0]  awprot,
    input logic        awvalid,
    input logic        awready,
    // Write data channel
    input logic [31:0] wdata,
    input logic [3:0]  wstrb,
    input logic        wvalid,
    input logic        wready,
    // Write response channel
    input logic [1:0]  bresp,
    input logic        bvalid,
    input logic        bready,
    // Read address channel
    input logic [31:0] araddr,
    input logic [2:0]  arprot,
    input logic        arvalid,
    input logic        arready,
    // Read data channel
    input logic [31:0] rdata,
    input logic [1:0]  rresp,
    input logic        rvalid,
    input logic        rready
);

    // ========== Handshake Protocol ==========

    // Once valid asserted, must remain until ready (Write Address)
    property awvalid_until_awready;
        @(posedge aclk) disable iff (!aresetn)
        (awvalid && !awready) |=> awvalid;
    endproperty
    aw_stable: assert property (awvalid_until_awready)
        else $error("AWVALID deasserted before AWREADY");

    // Address must be stable when valid and not ready
    property awaddr_stable;
        @(posedge aclk) disable iff (!aresetn)
        (awvalid && !awready) |=> $stable(awaddr) && $stable(awprot);
    endproperty
    aw_addr_stable: assert property (awaddr_stable)
        else $error("AWADDR/AWPROT changed while AWVALID high");

    // Similar for write data channel
    property wvalid_until_wready;
        @(posedge aclk) disable iff (!aresetn)
        (wvalid && !wready) |=> wvalid;
    endproperty
    w_stable: assert property (wvalid_until_wready);

    property wdata_stable;
        @(posedge aclk) disable iff (!aresetn)
        (wvalid && !wready) |=> ($stable(wdata) && $stable(wstrb));
    endproperty
    w_data_stable: assert property (wdata_stable);

    // Response channel
    property bvalid_until_bready;
        @(posedge aclk) disable iff (!aresetn)
        (bvalid && !bready) |=> bvalid;
    endproperty
    b_stable: assert property (bvalid_until_bready);

    property bresp_stable;
        @(posedge aclk) disable iff (!aresetn)
        (bvalid && !bready) |=> $stable(bresp);
    endproperty
    b_resp_stable: assert property (bresp_stable);

    // ========== Transaction Ordering ==========

    // Write response must follow write data completion
    property write_response_after_data;
        @(posedge aclk) disable iff (!aresetn)
        (wvalid && wready) |-> ##[0:16] bvalid;
    endproperty
    wr_resp_timing: assert property (write_response_after_data)
        else $error("Write response timeout");

    // Write address before or with write data
    sequence write_addr_accepted;
        awvalid && awready;
    endsequence

    sequence write_data_accepted;
        wvalid && wready;
    endsequence

    property addr_before_data;
        @(posedge aclk) disable iff (!aresetn)
        write_data_accepted |->
            $past(write_addr_accepted, 1) or write_addr_accepted;
    endproperty
    wr_addr_first: assert property (addr_before_data)
        else $error("Write data before address");

    // ========== Value Checks ==========

    // No X/Z on control signals when valid
    property no_x_awvalid;
        @(posedge aclk) disable iff (!aresetn)
        !$isunknown(awvalid);
    endproperty
    awvalid_no_x: assert property (no_x_awvalid)
        else $fatal("X/Z on AWVALID");

    property no_x_on_addr_when_valid;
        @(posedge aclk) disable iff (!aresetn)
        awvalid |-> !$isunknown(awaddr);
    endproperty
    awaddr_no_x: assert property (no_x_on_addr_when_valid);

    // ========== Coverage ==========

    // Cover interesting scenarios
    cover_aw_w_same_cycle: cover property (
        @(posedge aclk) disable iff (!aresetn)
        (awvalid && awready && wvalid && wready)
    );

    cover_max_aw_delay: cover property (
        @(posedge aclk) disable iff (!aresetn)
        (awvalid && !awready) ##15 (awvalid && awready)
    );

    cover_back_to_back_writes: cover property (
        @(posedge aclk) disable iff (!aresetn)
        (wvalid && wready) ##1 (wvalid && wready)
    );

    // ========== Read Channel Assertions ==========

    property arvalid_until_arready;
        @(posedge aclk) disable iff (!aresetn)
        (arvalid && !arready) |=> arvalid;
    endproperty
    ar_stable: assert property (arvalid_until_arready);

    property rvalid_until_rready;
        @(posedge aclk) disable iff (!aresetn)
        (rvalid && !rready) |=> rvalid;
    endproperty
    r_stable: assert property (rvalid_until_rready);

    // Read data must follow read address
    property read_data_after_addr;
        @(posedge aclk) disable iff (!aresetn)
        (arvalid && arready) |-> ##[1:16] rvalid;
    endproperty
    rd_data_timing: assert property (read_data_after_addr)
        else $error("Read data timeout");

endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 49: I2C Protocol Assertions}

Implement comprehensive SVA assertions for I2C:
\begin{itemize}
  \item START condition: SDA falls while SCL high
  \item STOP condition: SDA rises while SCL high
  \item Data stability: SDA stable when SCL high
  \item ACK timing: SDA low on 9th clock after address/data
  \item No bus contention detection
  \item Clock stretching support verification
\end{itemize}
\end{exercisebox}

\subsection{Assertion Methodology and Best Practices}

\begin{lstlisting}[caption={Binding Assertions to Design}]
// Design module
module fifo #(parameter DEPTH = 16, WIDTH = 8)(
    input  logic             clk,
    input  logic             rst_n,
    input  logic             wr_en,
    input  logic             rd_en,
    input  logic [WIDTH-1:0] wr_data,
    output logic [WIDTH-1:0] rd_data,
    output logic             full,
    output logic             empty,
    output logic [$clog2(DEPTH):0] count
);
    // FIFO implementation...
endmodule

// Assertions in separate module
module fifo_sva #(parameter DEPTH = 16, WIDTH = 8)(
    input logic             clk,
    input logic             rst_n,
    input logic             wr_en,
    input logic             rd_en,
    input logic [WIDTH-1:0] wr_data,
    input logic [WIDTH-1:0] rd_data,
    input logic             full,
    input logic             empty,
    input logic [$clog2(DEPTH):0] count
);

    // Mutex: full and empty cannot both be true
    property full_empty_mutex;
        @(posedge clk) disable iff (!rst_n)
        !(full && empty);
    endproperty
    a_mutex: assert property (full_empty_mutex)
        else $fatal("FIFO full and empty simultaneously");

    // Count range
    property count_in_range;
        @(posedge clk) disable iff (!rst_n)
        count <= DEPTH;
    endproperty
    a_count_range: assert property (count_in_range);

    // Full means count == DEPTH
    property full_means_max_count;
        @(posedge clk) disable iff (!rst_n)
        full |-> (count == DEPTH);
    endproperty
    a_full_count: assert property (full_means_max_count);

    // Empty means count == 0
    property empty_means_zero_count;
        @(posedge clk) disable iff (!rst_n)
        empty |-> (count == 0);
    endproperty
    a_empty_count: assert property (empty_means_zero_count);

    // Write increments count (if not full and no read)
    property write_increments;
        @(posedge clk) disable iff (!rst_n)
        (wr_en && !full && !rd_en) |=> (count == $past(count) + 1);
    endproperty
    a_wr_inc: assert property (write_increments);

    // Read decrements count
    property read_decrements;
        @(posedge clk) disable iff (!rst_n)
        (rd_en && !empty && !wr_en) |=> (count == $past(count) - 1);
    endproperty
    a_rd_dec: assert property (read_decrements);

    // Simultaneous read/write keeps count stable
    property simul_rd_wr;
        @(posedge clk) disable iff (!rst_n)
        (wr_en && rd_en && !full && !empty) |=> (count == $past(count));
    endproperty
    a_simul: assert property (simul_rd_wr);

    // Data stability when writing
    property wr_data_stable;
        @(posedge clk) disable iff (!rst_n)
        (wr_en && !full) |-> !$isunknown(wr_data);
    endproperty
    a_wr_stable: assert property (wr_data_stable);

    // Coverage
    c_full: cover property (@(posedge clk) disable iff (!rst_n) full);
    c_empty: cover property (@(posedge clk) disable iff (!rst_n) empty);
    c_half_full: cover property (
        @(posedge clk) disable iff (!rst_n) (count == DEPTH/2)
    );
    c_back_to_back_wr: cover property (
        @(posedge clk) disable iff (!rst_n) (wr_en && !full) ##1 (wr_en && !full)
    );

endmodule

// Top level with bind
module fifo_top;
    logic clk, rst_n;
    // ... other signals ...

    fifo #(.DEPTH(16), .WIDTH(8)) dut (.*);

    // Bind assertions
    bind fifo fifo_sva #(.DEPTH(DEPTH), .WIDTH(WIDTH))
        sva_inst (.*);

endmodule
\end{lstlisting}

\subsection{Quiz: SystemVerilog Assertions}

\begin{quizbox}
\textbf{Quiz 16: SVA Mastery}

\begin{enumerate}
  \item What's the difference between |-> and |=> operators?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What does [*3] mean in a sequence? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What's the difference between [=3] and [->3]?

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item When should you use assume vs assert? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What does throughout operator ensure? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item |-> is overlapping (checks same cycle); |=> is non-overlapping (checks next cycle)
  \item Signal is true for exactly 3 consecutive cycles
  \item [=3] means 3 occurrences (not necessarily consecutive); [->3] means on 3rd occurrence
  \item Use assert to verify DUT behavior; assume to constrain inputs in formal verification
  \item A signal/condition remains true throughout the entire sequence duration
\end{enumerate}
\end{quizbox}

\newpage
% ============================================================================
\section{Advanced Randomization and Constraints}

\subsection{Constraint Layering and Modes}

Advanced constrained random verification requires sophisticated control over constraint activation:

\begin{lstlisting}[caption={Multi-Mode Constraint Architecture}]
class ConfigurableTransaction;
    rand bit [31:0] address;
    rand bit [31:0] data;
    rand bit [7:0]  burst_len;
    rand bit        is_write;
    rand bit [3:0]  id;

    // Test modes
    typedef enum {
        NORMAL_MODE,
        STRESS_MODE,
        CORNER_CASE_MODE,
        DEBUG_MODE
    } test_mode_t;

    test_mode_t current_mode = NORMAL_MODE;

    // Always-active base constraints
    constraint base_constraints {
        burst_len inside {[1:16]};
        address[1:0] == 2'b00;  // Word aligned
        id < 8;
    }

    // Mode-specific constraints
    constraint normal_mode_c {
        if (current_mode == NORMAL_MODE) {
            address inside {[32'h0000_0000:32'h0000_FFFF]};
            burst_len inside {[1:4]};
            is_write dist {1 := 60, 0 := 40};
        }
    }

    constraint stress_mode_c {
        if (current_mode == STRESS_MODE) {
            burst_len == 16;  // Max burst
            address[31:20] == 12'hFFF;  // High memory
            is_write dist {1 := 90, 0 := 10};  // Mostly writes
        }
    }

    constraint corner_case_c {
        if (current_mode == CORNER_CASE_MODE) {
            address inside {
                32'h0000_0000,  // Start of memory
                32'h0000_FFFC,  // End of low memory
                32'hFFFF_0000,  // Start of high memory
                32'hFFFF_FFFC   // End of memory
            };
            burst_len inside {1, 16};  // Min or max
        }
    }

    constraint debug_mode_c {
        if (current_mode == DEBUG_MODE) {
            address == 32'h1000;  // Fixed address
            burst_len == 1;       // Single transfer
        }
    }

    function void set_mode(test_mode_t mode);
        current_mode = mode;
        $display("Mode changed to: %s", mode.name());
    endfunction

    function void display(string prefix = "");
        $display("%s [%s] %s: Addr=0x%h Data=0x%h Len=%0d ID=%0d",
                 prefix, current_mode.name(),
                 is_write ? "WR" : "RD",
                 address, data, burst_len, id);
    endfunction
endclass

module constraint_modes_example;
    initial begin
        ConfigurableTransaction trans = new();

        $display("\n=== NORMAL MODE ===");
        trans.set_mode(ConfigurableTransaction::NORMAL_MODE);
        repeat(5) begin
            assert(trans.randomize());
            trans.display();
        end

        $display("\n=== STRESS MODE ===");
        trans.set_mode(ConfigurableTransaction::STRESS_MODE);
        repeat(5) begin
            assert(trans.randomize());
            trans.display();
        end

        $display("\n=== CORNER CASE MODE ===");
        trans.set_mode(ConfigurableTransaction::CORNER_CASE_MODE);
        repeat(5) begin
            assert(trans.randomize());
            trans.display();
        end
    end
endmodule
\end{lstlisting}

\subsection{Advanced Inline Constraints and Constraint Override}

\begin{lstlisting}[caption={Dynamic Constraint Control}]
class FlexiblePacket;
    rand bit [15:0] length;
    rand bit [7:0]  data[];
    rand bit [3:0]  priority;
    rand bit        error_inject;

    constraint length_c {
        length inside {[64:512]};
        length % 64 == 0;  // Cache line aligned
    }

    constraint data_size_c {
        data.size() == length;
    }

    constraint priority_c {
        priority dist {
            [0:3]   := 70,   // Low priority: 70%
            [4:7]   := 20,   // Medium: 20%
            [8:15]  := 10    // High: 10%
        };
    }

    constraint error_c {
        error_inject dist {0 := 95, 1 := 5};  // 5% error rate
    }

    function void display();
        $display("Len=%0d Pri=%0d Err=%0b DataSize=%0d",
                 length, priority, error_inject, data.size());
    endfunction
endclass

module inline_constraint_demo;
    initial begin
        FlexiblePacket pkt = new();

        $display("=== Standard Randomization ===");
        repeat(3) begin
            assert(pkt.randomize());
            pkt.display();
        end

        $display("\n=== With Inline Constraints ===");
        // Override with inline constraints
        assert(pkt.randomize() with {
            length == 256;
            priority == 15;  // Highest priority
            error_inject == 1;
        });
        pkt.display();

        $display("\n=== Inline Constraint on Array ===");
        assert(pkt.randomize() with {
            length == 128;
            foreach(data[i]) {
                if (i < 10)
                    data[i] == i;  // First 10 = sequential
                else
                    data[i] inside {[100:200]};
            }
        });
        $display("First 10 elements: %p", pkt.data[0:9]);

        $display("\n=== Disable Constraint ===");
        pkt.length_c.constraint_mode(0);  // Disable
        assert(pkt.randomize() with {
            length == 1000;  // Would violate length_c if enabled
        });
        pkt.display();
        pkt.length_c.constraint_mode(1);  // Re-enable

        $display("\n=== Randomize Specific Variables ===");
        pkt.length = 192;
        pkt.priority = 10;
        // Randomize only data array
        assert(pkt.randomize(data));
        pkt.display();
    end
endmodule
\end{lstlisting}

\subsection{Solve-Before and Constraint Ordering}

\begin{lstlisting}[caption={Constraint Solving Order Control}]
class ConstraintOrderPacket;
    rand bit [7:0] packet_type;
    rand bit [15:0] length;
    rand bit [7:0] header_len;
    rand bit [7:0] payload_len;

    // Ensure packet_type is solved first
    // Then length depends on type
    // Then header and payload are divided from length
    constraint solve_order {
        solve packet_type before length;
        solve length before header_len, payload_len;
    }

    constraint type_c {
        packet_type inside {[0:3]};
    }

    constraint length_from_type {
        if (packet_type == 0)      length == 64;
        else if (packet_type == 1) length == 128;
        else if (packet_type == 2) length == 256;
        else                       length == 512;
    }

    constraint split_length {
        header_len + payload_len == length;
        header_len inside {[20:60]};
    }

    function void display();
        $display("Type=%0d Len=%0d Hdr=%0d Payload=%0d (Sum=%0d)",
                 packet_type, length, header_len, payload_len,
                 header_len + payload_len);
    endfunction
endclass

// Example with cyclic dependency resolution
class CyclicDependency;
    rand bit [7:0] a, b, c;

    constraint circular {
        a < b;
        b < c;
        c < a + 50;  // Creates dependency cycle
    }

    // Break cycle with solve-before
    constraint solve_cycle {
        solve a before b;
        solve b before c;
    }
endclass

module constraint_order_example;
    initial begin
        ConstraintOrderPacket pkt = new();

        $display("=== Constraint Ordering Demo ===");
        repeat(10) begin
            assert(pkt.randomize());
            pkt.display();
        end

        $display("\n=== Cyclic Dependency Resolution ===");
        CyclicDependency cyc = new();
        repeat(5) begin
            assert(cyc.randomize());
            $display("a=%0d b=%0d c=%0d", cyc.a, cyc.b, cyc.c);
        end
    end
endmodule
\end{lstlisting}

\subsection{Random Stability with rand\_mode}

\begin{lstlisting}[caption={Selective Randomization Control}]
class SelectiveRandom;
    rand bit [31:0] address;
    rand bit [31:0] data;
    rand bit [7:0]  burst_len;
    rand bit        is_write;

    constraint addr_c {
        address inside {[32'h1000:32'h1FFF]};
    }

    function void display();
        $display("Addr=0x%h Data=0x%h Len=%0d %s",
                 address, data, burst_len, is_write ? "WR" : "RD");
    endfunction
endclass

module rand_mode_example;
    initial begin
        SelectiveRandom obj = new();

        $display("=== Full Randomization ===");
        repeat(3) begin
            assert(obj.randomize());
            obj.display();
        end

        $display("\n=== Keep address constant, randomize rest ===");
        obj.address = 32'h1234;
        obj.rand_mode(0);  // Disable randomization for all
        obj.address.rand_mode(0);  // Keep address
        obj.data.rand_mode(1);     // Randomize data
        obj.burst_len.rand_mode(1);
        obj.is_write.rand_mode(1);

        // Actually, better way:
        obj.rand_mode(1);  // Re-enable all
        obj.address.rand_mode(0);  // Disable just address

        repeat(3) begin
            assert(obj.randomize());
            obj.display();  // Address stays 0x1234
        end

        $display("\n=== Randomize only data ===");
        obj.rand_mode(0);  // Disable all
        obj.data.rand_mode(1);  // Enable only data
        repeat(3) begin
            assert(obj.randomize());
            obj.display();
        end
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 50: Advanced Transaction Generator}

Create a sophisticated transaction generator with:
\begin{itemize}
  \item Multiple operation modes (normal, stress, corner, debug)
  \item Constraint layering based on mode
  \item Solve-before to establish dependencies
  \item Inline constraints for special test cases
  \item Pre/post randomize for statistics and validation
  \item Generate 1000 transactions and verify distributions
  \item Support for selective randomization (fixed address, random data)
\end{itemize}
\end{exercisebox}

\subsection{Quiz: Advanced Randomization}

\begin{quizbox}
\textbf{Quiz 17: Advanced Constraints}

\begin{enumerate}
  \item How do you temporarily disable a constraint? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What does solve X before Y do? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

  \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item When is pre\_randomize() called? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item How do you randomize only specific variables? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
  \item What's the advantage of constraint modes? \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
  \item \texttt{constraint\_name.constraint\_mode(0)}; re-enable with (1)
  \item Forces constraint solver to determine X's value before solving for Y; breaks cyclic dependencies
  \item Before randomize() is called; used to set up conditions that affect constraints
  \item \texttt{randomize(var1, var2)} or use rand\_mode() to disable others
  \item Allows switching between different constraint sets without modifying class
\end{enumerate}
\end{quizbox}

%============================================================================
\section{Design Patterns in SystemVerilog}
%============================================================================

Design patterns are reusable solutions to common problems in software design. In SystemVerilog verification, several patterns have emerged as best practices for building scalable, maintainable testbenches.

%----------------------------------------------------------------------------
\subsection{The Singleton Pattern}
%----------------------------------------------------------------------------

The Singleton pattern ensures that only one instance of a class exists throughout the simulation. This is commonly used for configuration databases, message handlers, and global resources.

\begin{lstlisting}
class Config;
    static local Config m_instance = null;

    // Configuration parameters
    int num_transactions = 100;
    bit enable_coverage = 1;
    string test_name = "default_test";

    // Private constructor prevents direct instantiation
    local function new();
    endfunction

    // Static method to get the singleton instance
    static function Config get();
        if (m_instance == null) begin
            m_instance = new();
            $display("Config singleton created");
        end
        return m_instance;
    endfunction

    // Configuration methods
    function void set_num_transactions(int n);
        num_transactions = n;
        $display("Set num_transactions = %0d", n);
    endfunction

    function void print_config();
        $display("=== Configuration ===");
        $display("Test Name: %s", test_name);
        $display("Num Transactions: %0d", num_transactions);
        $display("Coverage Enabled: %0d", enable_coverage);
    endfunction
endclass

// Usage example
module test_singleton;
    initial begin
        Config cfg1, cfg2;

        // Get singleton instances
        cfg1 = Config::get();
        cfg2 = Config::get();

        // Both references point to the same object
        cfg1.set_num_transactions(500);
        cfg2.print_config();  // Shows 500, proving same instance

        if (cfg1 == cfg2)
            $display("SUCCESS: cfg1 and cfg2 are the same instance");
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{The Factory Pattern}
%----------------------------------------------------------------------------

The Factory pattern provides an interface for creating objects without specifying their exact class. This is essential for creating different transaction types based on test configuration.

\begin{lstlisting}
// Base transaction class
virtual class BaseTransaction;
    rand bit [31:0] addr;
    rand bit [31:0] data;
    typedef enum {READ, WRITE, BURST} trans_type_t;
    rand trans_type_t trans_type;

    pure virtual function void display();
    pure virtual function BaseTransaction clone();
endclass

// Read transaction
class ReadTransaction extends BaseTransaction;
    rand bit [3:0] burst_len;

    constraint read_c { trans_type == READ; }

    virtual function void display();
        $display("READ: addr=0x%0h, burst_len=%0d", addr, burst_len);
    endfunction

    virtual function BaseTransaction clone();
        ReadTransaction rt = new();
        rt.addr = this.addr;
        rt.burst_len = this.burst_len;
        return rt;
    endfunction
endclass

// Write transaction
class WriteTransaction extends BaseTransaction;
    rand bit [7:0] byte_enable;

    constraint write_c { trans_type == WRITE; }

    virtual function void display();
        $display("WRITE: addr=0x%0h, data=0x%0h, be=0x%0h",
                 addr, data, byte_enable);
    endfunction

    virtual function BaseTransaction clone();
        WriteTransaction wt = new();
        wt.addr = this.addr;
        wt.data = this.data;
        wt.byte_enable = this.byte_enable;
        return wt;
    endfunction
endclass

// Burst transaction
class BurstTransaction extends BaseTransaction;
    rand bit [31:0] data_queue[$];
    rand int burst_length;

    constraint burst_c {
        trans_type == BURST;
        burst_length inside {[4:16]};
        data_queue.size() == burst_length;
    }

    virtual function void display();
        $display("BURST: addr=0x%0h, length=%0d", addr, burst_length);
        foreach(data_queue[i])
            $display("  [%0d]: 0x%0h", i, data_queue[i]);
    endfunction

    virtual function BaseTransaction clone();
        BurstTransaction bt = new();
        bt.addr = this.addr;
        bt.burst_length = this.burst_length;
        bt.data_queue = this.data_queue;
        return bt;
    endfunction
endclass

// Transaction Factory
class TransactionFactory;
    typedef enum {READ_TYPE, WRITE_TYPE, BURST_TYPE} factory_type_t;

    // Factory method
    static function BaseTransaction create(factory_type_t t_type);
        case (t_type)
            READ_TYPE:  return new ReadTransaction();
            WRITE_TYPE: return new WriteTransaction();
            BURST_TYPE: return new BurstTransaction();
            default: begin
                $error("Unknown transaction type");
                return null;
            end
        endcase
    endfunction

    // Random factory method
    static function BaseTransaction create_random();
        factory_type_t t = factory_type_t'($urandom_range(0, 2));
        return create(t);
    endfunction
endclass

// Usage example
module test_factory;
    initial begin
        BaseTransaction trans;

        // Create specific transaction types
        trans = TransactionFactory::create(TransactionFactory::READ_TYPE);
        assert(trans.randomize());
        trans.display();

        trans = TransactionFactory::create(TransactionFactory::WRITE_TYPE);
        assert(trans.randomize());
        trans.display();

        // Create random transactions
        repeat(5) begin
            trans = TransactionFactory::create_random();
            assert(trans.randomize());
            trans.display();
        end
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{The Observer Pattern}
%----------------------------------------------------------------------------

The Observer pattern defines a one-to-many dependency where multiple observers are notified when a subject changes state. This is useful for event notification in verification environments.

\begin{lstlisting}
// Observer interface
virtual class Observer;
    pure virtual task update(string event_name, int event_data);
endclass

// Subject (Observable)
class EventBroadcaster;
    local Observer observers[$];

    // Subscribe an observer
    function void attach(Observer obs);
        observers.push_back(obs);
        $display("Observer attached, total: %0d", observers.size());
    endfunction

    // Unsubscribe an observer
    function void detach(Observer obs);
        int index[$];
        index = observers.find_index with (item == obs);
        if (index.size() > 0)
            observers.delete(index[0]);
    endfunction

    // Notify all observers
    task notify(string event_name, int event_data);
        $display("Broadcasting event: %s (data=%0d)", event_name, event_data);
        foreach(observers[i]) begin
            fork
                automatic int idx = i;
                observers[idx].update(event_name, event_data);
            join_none
        end
        wait fork;  // Wait for all notifications to complete
    endtask
endclass

// Concrete Observer: Coverage Collector
class CoverageCollector extends Observer;
    string name;
    int events_received = 0;

    function new(string n);
        name = n;
    endfunction

    virtual task update(string event_name, int event_data);
        events_received++;
        $display("[%s] Received event: %s, data=%0d (total: %0d)",
                 name, event_name, event_data, events_received);
        #1ns;  // Simulate processing time
    endtask
endclass

// Concrete Observer: Scoreboard
class Scoreboard extends Observer;
    int total_score = 0;

    virtual task update(string event_name, int event_data);
        total_score += event_data;
        $display("[Scoreboard] Event: %s, Score: %0d, Total: %0d",
                 event_name, event_data, total_score);
        #2ns;  // Simulate processing time
    endtask
endclass

// Concrete Observer: Logger
class Logger extends Observer;
    int log_count = 0;

    virtual task update(string event_name, int event_data);
        log_count++;
        $display("[Logger-%0d] %s: 0x%0h", log_count, event_name, event_data);
    endtask
endclass

// Usage example
module test_observer;
    initial begin
        EventBroadcaster broadcaster;
        CoverageCollector cov1, cov2;
        Scoreboard sb;
        Logger log;

        broadcaster = new();
        cov1 = new("Coverage1");
        cov2 = new("Coverage2");
        sb = new();
        log = new();

        // Subscribe observers
        broadcaster.attach(cov1);
        broadcaster.attach(cov2);
        broadcaster.attach(sb);
        broadcaster.attach(log);

        // Trigger events
        broadcaster.notify("TRANSACTION_START", 100);
        #10ns;
        broadcaster.notify("TRANSACTION_COMPLETE", 200);
        #10ns;

        // Detach one observer and trigger again
        broadcaster.detach(cov2);
        broadcaster.notify("ERROR_DETECTED", 42);
        #10ns;
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{The Strategy Pattern}
%----------------------------------------------------------------------------

The Strategy pattern defines a family of algorithms and makes them interchangeable. In verification, this is used to switch between different protocol implementations or stimulus generation strategies.

\begin{lstlisting}
// Strategy interface
virtual class TransferStrategy;
    pure virtual task execute(bit [31:0] addr, bit [31:0] data);
    pure virtual function string get_name();
endclass

// Concrete Strategy: AXI Transfer
class AXIStrategy extends TransferStrategy;
    virtual task execute(bit [31:0] addr, bit [31:0] data);
        $display("[AXI] Starting transfer");
        $display("  AWADDR = 0x%0h", addr);
        $display("  AWVALID = 1");
        #10ns;
        $display("  AWREADY = 1");
        $display("  WDATA = 0x%0h", data);
        $display("  WVALID = 1");
        #10ns;
        $display("  WREADY = 1");
        $display("  BRESP = 2'b00 (OKAY)");
        $display("[AXI] Transfer complete");
    endtask

    virtual function string get_name();
        return "AXI4";
    endfunction
endclass

// Concrete Strategy: APB Transfer
class APBStrategy extends TransferStrategy;
    virtual task execute(bit [31:0] addr, bit [31:0] data);
        $display("[APB] Starting transfer");
        $display("  PADDR = 0x%0h", addr);
        $display("  PSEL = 1, PENABLE = 0");
        #10ns;
        $display("  PENABLE = 1");
        $display("  PWDATA = 0x%0h", data);
        #10ns;
        $display("  PREADY = 1");
        $display("[APB] Transfer complete");
    endtask

    virtual function string get_name();
        return "APB";
    endfunction
endclass

// Concrete Strategy: Avalon Transfer
class AvalonStrategy extends TransferStrategy;
    virtual task execute(bit [31:0] addr, bit [31:0] data);
        $display("[Avalon] Starting transfer");
        $display("  address = 0x%0h", addr);
        $display("  writedata = 0x%0h", data);
        $display("  write = 1");
        #20ns;  // Wait for waitrequest
        $display("  waitrequest = 0");
        $display("[Avalon] Transfer complete");
    endtask

    virtual function string get_name();
        return "Avalon-MM";
    endfunction
endclass

// Context class that uses a strategy
class ProtocolDriver;
    TransferStrategy strategy;

    function void set_strategy(TransferStrategy s);
        strategy = s;
        $display("Protocol strategy set to: %s", s.get_name());
    endfunction

    task drive_transfer(bit [31:0] addr, bit [31:0] data);
        if (strategy == null) begin
            $error("No strategy set!");
            return;
        end
        strategy.execute(addr, data);
    endtask
endclass

// Usage example
module test_strategy;
    initial begin
        ProtocolDriver driver;
        AXIStrategy axi_strat;
        APBStrategy apb_strat;
        AvalonStrategy avalon_strat;

        driver = new();
        axi_strat = new();
        apb_strat = new();
        avalon_strat = new();

        // Use AXI protocol
        driver.set_strategy(axi_strat);
        driver.drive_transfer(32'h1000, 32'hDEADBEEF);
        #20ns;

        // Switch to APB protocol
        driver.set_strategy(apb_strat);
        driver.drive_transfer(32'h2000, 32'hCAFEBABE);
        #20ns;

        // Switch to Avalon protocol
        driver.set_strategy(avalon_strat);
        driver.drive_transfer(32'h3000, 32'h12345678);
        #20ns;

        $display("\n=== Strategy Pattern Demo Complete ===");
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{The Builder Pattern}
%----------------------------------------------------------------------------

The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

\begin{lstlisting}
// Complex product: Verification Environment
class VerificationEnvironment;
    string name;
    int num_agents;
    bit has_scoreboard;
    bit has_coverage;
    bit has_monitor;
    string protocol_type;

    function void display();
        $display("=== Verification Environment: %s ===", name);
        $display("  Agents: %0d", num_agents);
        $display("  Protocol: %s", protocol_type);
        $display("  Scoreboard: %s", has_scoreboard ? "Yes" : "No");
        $display("  Coverage: %s", has_coverage ? "Yes" : "No");
        $display("  Monitor: %s", has_monitor ? "Yes" : "No");
    endfunction
endclass

// Abstract Builder
virtual class EnvironmentBuilder;
    protected VerificationEnvironment env;

    function new();
        env = new();
    endfunction

    pure virtual function void build_agents();
    pure virtual function void build_scoreboard();
    pure virtual function void build_coverage();
    pure virtual function void build_monitor();
    pure virtual function void set_protocol();

    function VerificationEnvironment get_result();
        return env;
    endfunction
endclass

// Concrete Builder: Simple Test Environment
class SimpleTestBuilder extends EnvironmentBuilder;
    function new();
        super.new();
        env.name = "Simple Test Environment";
    endfunction

    virtual function void build_agents();
        env.num_agents = 1;
    endfunction

    virtual function void build_scoreboard();
        env.has_scoreboard = 0;  // Simple test doesn't need scoreboard
    endfunction

    virtual function void build_coverage();
        env.has_coverage = 0;
    endfunction

    virtual function void build_monitor();
        env.has_monitor = 1;  // Basic monitoring
    endfunction

    virtual function void set_protocol();
        env.protocol_type = "APB";
    endfunction
endclass

// Concrete Builder: Advanced Verification Environment
class AdvancedVerifBuilder extends EnvironmentBuilder;
    function new();
        super.new();
        env.name = "Advanced Verification Environment";
    endfunction

    virtual function void build_agents();
        env.num_agents = 4;  // Multiple agents
    endfunction

    virtual function void build_scoreboard();
        env.has_scoreboard = 1;
    endfunction

    virtual function void build_coverage();
        env.has_coverage = 1;
    endfunction

    virtual function void build_monitor();
        env.has_monitor = 1;
    endfunction

    virtual function void set_protocol();
        env.protocol_type = "AXI4";
    endfunction
endclass

// Concrete Builder: Regression Test Environment
class RegressionTestBuilder extends EnvironmentBuilder;
    function new();
        super.new();
        env.name = "Regression Test Environment";
    endfunction

    virtual function void build_agents();
        env.num_agents = 2;
    endfunction

    virtual function void build_scoreboard();
        env.has_scoreboard = 1;
    endfunction

    virtual function void build_coverage();
        env.has_coverage = 1;  // Full coverage for regression
    endfunction

    virtual function void build_monitor();
        env.has_monitor = 1;
    endfunction

    virtual function void set_protocol();
        env.protocol_type = "AXI4-Stream";
    endfunction
endclass

// Director
class EnvironmentDirector;
    EnvironmentBuilder builder;

    function void set_builder(EnvironmentBuilder b);
        builder = b;
    endfunction

    function VerificationEnvironment construct();
        builder.set_protocol();
        builder.build_agents();
        builder.build_scoreboard();
        builder.build_coverage();
        builder.build_monitor();
        return builder.get_result();
    endfunction
endclass

// Usage example
module test_builder;
    initial begin
        EnvironmentDirector director;
        SimpleTestBuilder simple_builder;
        AdvancedVerifBuilder advanced_builder;
        RegressionTestBuilder regression_builder;
        VerificationEnvironment env;

        director = new();

        // Build simple environment
        simple_builder = new();
        director.set_builder(simple_builder);
        env = director.construct();
        env.display();
        $display("");

        // Build advanced environment
        advanced_builder = new();
        director.set_builder(advanced_builder);
        env = director.construct();
        env.display();
        $display("");

        // Build regression environment
        regression_builder = new();
        director.set_builder(regression_builder);
        env = director.construct();
        env.display();
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 51: Implement a Prototype Pattern}

Create a \texttt{TransactionPrototype} class that implements the Prototype pattern for deep copying transactions. Include:
\begin{itemize}
    \item A \texttt{clone()} method for creating deep copies
    \item Support for nested objects (e.g., transaction with embedded descriptor)
    \item A prototype registry for managing prototypes
    \item Demonstration of cloning vs. shallow copying
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 52: Command Pattern for Test Sequences}

Implement the Command pattern to create reusable test sequences:
\begin{itemize}
    \item Abstract \texttt{Command} class with \texttt{execute()} and \texttt{undo()} methods
    \item Concrete commands: \texttt{WriteCommand}, \texttt{ReadCommand}, \texttt{DelayCommand}
    \item \texttt{CommandInvoker} to manage command queues
    \item Support for command history and replay
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 53: Combine Multiple Patterns}

Create a verification environment that combines:
\begin{itemize}
    \item Singleton for configuration
    \item Factory for creating transactions
    \item Observer for event notification
    \item Strategy for protocol switching
    \item Demonstrate how patterns work together
\end{itemize}
\end{exercisebox}

\begin{quizbox}
\textbf{Quiz 18: Design Patterns}

\begin{enumerate}
    \item What is the main purpose of the Singleton pattern in verification?
    \item How does the Factory pattern improve testbench flexibility?
    \item In the Observer pattern, what happens when \texttt{notify()} is called?
    \item Why is the Strategy pattern useful for multi-protocol verification?
    \item What advantage does the Builder pattern provide over direct object construction?
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
    \item Ensures only one instance of a class (e.g., configuration) exists globally; prevents multiple conflicting configurations
    \item Decouples transaction creation from specific types; allows runtime selection of transaction types without modifying client code
    \item All registered observers are notified concurrently; each observer's \texttt{update()} method is called with event data
    \item Allows switching between protocol implementations (AXI, APB, Avalon) without changing driver code; promotes code reuse
    \item Separates complex construction from representation; same builder process can create different configurations; improves readability
\end{enumerate}
\end{quizbox}

\begin{tipbox}
\textbf{Pattern Selection Guidelines:}
\begin{itemize}
    \item \textbf{Singleton}: Global configuration, message handlers, resource managers
    \item \textbf{Factory}: Creating polymorphic objects based on runtime conditions
    \item \textbf{Observer}: Event-driven architectures, scoreboarding, coverage collection
    \item \textbf{Strategy}: Protocol abstraction, interchangeable algorithms
    \item \textbf{Builder}: Complex object construction with many optional components
\end{itemize}
\end{tipbox}

%============================================================================
\section{Advanced Functional Coverage}
%============================================================================

Functional coverage measures how well the verification environment has exercised the design's functionality. Advanced coverage techniques help ensure comprehensive verification and identify coverage holes.

%----------------------------------------------------------------------------
\subsection{Covergroup Basics and Options}
%----------------------------------------------------------------------------

Covergroups define what to measure. Coverage options control how coverage is measured and reported.

\begin{lstlisting}
class AdvancedCoverageExample;
    bit [7:0] data;
    bit [1:0] mode;
    bit error;

    // Covergroup with advanced options
    covergroup cg_advanced @(posedge clk);
        option.per_instance = 1;  // Separate coverage per instance
        option.at_least = 5;      // Each bin hit at least 5 times
        option.auto_bin_max = 8;  // Auto bins limited to 8
        option.comment = "Advanced coverage example";

        // Simple coverpoint with automatic bins
        cp_data: coverpoint data {
            option.weight = 2;  // Higher weight for this coverpoint
        }

        // Coverpoint with explicit bins
        cp_mode: coverpoint mode {
            bins low_mode  = {0};
            bins mid_mode  = {1, 2};
            bins high_mode = {3};
            option.weight = 1;
        }

        // Coverpoint with range bins
        cp_data_ranges: coverpoint data {
            bins low    = {[0:63]};
            bins medium = {[64:191]};
            bins high   = {[192:255]};
        }

        // Wildcard bins
        cp_data_pattern: coverpoint data {
            wildcard bins pattern_0x = {8'b0000_????};
            wildcard bins pattern_f0 = {8'b1111_0???};
            wildcard bins pattern_aa = {8'b1010_1010};
        }

        // Transition bins
        cp_mode_transitions: coverpoint mode {
            bins trans_0_1 = (0 => 1);
            bins trans_1_2 = (1 => 2);
            bins trans_2_3 = (2 => 3);
            bins trans_any = (0,1,2,3 => 0,1,2,3);  // All transitions
            bins trans_seq = (0 => 1 => 2 => 3);    // Specific sequence
        }

        // Illegal and ignore bins
        cp_data_special: coverpoint data {
            bins valid = {[0:250]};
            illegal_bins forbidden = {251, 252};
            ignore_bins  reserved  = {[253:255]};
        }
    endgroup

    function new();
        cg_advanced = new();
    endfunction

    function void sample(bit [7:0] d, bit [1:0] m);
        data = d;
        mode = m;
        cg_advanced.sample();
    endfunction
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Cross Coverage}
%----------------------------------------------------------------------------

Cross coverage captures interactions between multiple variables, which is crucial for finding corner cases.

\begin{lstlisting}
class TransactionCoverage;
    typedef enum {READ, WRITE, BURST} trans_type_t;
    typedef enum {OKAY, EXOKAY, SLVERR, DECERR} resp_type_t;

    trans_type_t trans_type;
    resp_type_t  response;
    bit [3:0]    burst_len;
    bit [2:0]    burst_size;

    covergroup cg_transaction;
        // Individual coverpoints
        cp_type: coverpoint trans_type;

        cp_resp: coverpoint response;

        cp_burst_len: coverpoint burst_len {
            bins small  = {[1:4]};
            bins medium = {[5:8]};
            bins large  = {[9:16]};
        }

        cp_size: coverpoint burst_size {
            bins byte_transfer = {0};
            bins half_transfer = {1};
            bins word_transfer = {2};
            bins dword_transfer = {3};
        }

        // Cross coverage: type x response
        cross_type_resp: cross cp_type, cp_resp {
            // Some combinations are illegal
            illegal_bins illegal_burst_error =
                binsof(cp_type) intersect {BURST} &&
                binsof(cp_resp) intersect {SLVERR, DECERR};
        }

        // Cross coverage: type x burst_len x size
        cross_burst_params: cross cp_type, cp_burst_len, cp_size {
            // Only care about burst transactions
            ignore_bins non_burst =
                binsof(cp_type) intersect {READ, WRITE};

            // Large bursts with byte transfers are interesting
            bins large_byte_bursts =
                binsof(cp_burst_len) intersect {[9:16]} &&
                binsof(cp_size) intersect {0};
        }

        // Advanced cross with explicit bins
        cross_detailed: cross cp_type, cp_resp {
            bins read_ok    = binsof(cp_type) intersect {READ} &&
                              binsof(cp_resp) intersect {OKAY};
            bins write_ok   = binsof(cp_type) intersect {WRITE} &&
                              binsof(cp_resp) intersect {OKAY};
            bins any_error  = binsof(cp_resp) intersect {SLVERR, DECERR};

            // Ignore some crosses
            ignore_bins read_exokay = binsof(cp_type) intersect {READ} &&
                                      binsof(cp_resp) intersect {EXOKAY};
        }
    endgroup

    function new();
        cg_transaction = new();
    endfunction
endclass

// Usage example with comprehensive coverage
module test_cross_coverage;
    initial begin
        TransactionCoverage tc;
        tc = new();

        // Sample various scenarios
        tc.trans_type = TransactionCoverage::READ;
        tc.response = TransactionCoverage::OKAY;
        tc.burst_len = 4;
        tc.burst_size = 2;
        tc.cg_transaction.sample();

        tc.trans_type = TransactionCoverage::BURST;
        tc.response = TransactionCoverage::OKAY;
        tc.burst_len = 16;
        tc.burst_size = 0;  // Large byte burst - interesting case
        tc.cg_transaction.sample();

        // Print coverage
        $display("Coverage: %0.2f%%", tc.cg_transaction.get_coverage());
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Coverage-Driven Verification}
%----------------------------------------------------------------------------

Using coverage feedback to guide stimulus generation and identify coverage holes.

\begin{lstlisting}
class CoverageDrivenGenerator;
    rand bit [7:0] address;
    rand bit [1:0] mode;
    rand bit [3:0] burst;

    // Coverage-driven constraints
    bit enable_address_focus = 0;
    bit enable_mode_focus = 0;

    // Track what we've covered
    bit address_low_covered = 0;
    bit address_high_covered = 0;

    covergroup cg_stimulus;
        cp_addr: coverpoint address {
            bins low    = {[0:63]};
            bins medium = {[64:191]};
            bins high   = {[192:255]};
        }

        cp_mode: coverpoint mode;

        cp_burst: coverpoint burst {
            bins small = {[1:4]};
            bins large = {[5:15]};
        }

        cross_addr_mode: cross cp_addr, cp_mode;
    endgroup

    constraint c_directed {
        // Use coverage feedback to direct stimulus
        if (enable_address_focus && !address_low_covered) {
            address inside {[0:63]};
        }
        if (enable_address_focus && !address_high_covered) {
            address inside {[192:255]};
        }
        if (enable_mode_focus) {
            mode dist {0 := 10, [1:2] := 30, 3 := 60};
        }
    }

    function new();
        cg_stimulus = new();
    endfunction

    function void update_coverage_state();
        real cov;
        // Check coverage for specific bins
        cov = cg_stimulus.cp_addr.get_inst_coverage();

        // This is simplified - in reality, you'd query specific bins
        if (cov > 30.0) address_low_covered = 1;
        if (cov > 60.0) address_high_covered = 1;
    endfunction

    task run_coverage_driven_test(int num_iterations);
        for (int i = 0; i < num_iterations; i++) begin
            // Generate stimulus
            assert(this.randomize());

            // Apply stimulus (simplified)
            $display("[%0d] addr=0x%0h, mode=%0d, burst=%0d",
                     i, address, mode, burst);

            // Sample coverage
            cg_stimulus.sample();

            // Update coverage state every 10 iterations
            if (i % 10 == 0) begin
                update_coverage_state();
                real current_cov = cg_stimulus.get_coverage();
                $display("  Coverage: %0.2f%%", current_cov);

                // Adjust stimulus based on coverage
                if (current_cov < 50.0)
                    enable_address_focus = 1;
                else if (current_cov < 80.0)
                    enable_mode_focus = 1;
            end
        end

        // Final coverage report
        $display("\n=== Final Coverage Report ===");
        $display("Overall: %0.2f%%", cg_stimulus.get_coverage());
        $display("Address: %0.2f%%", cg_stimulus.cp_addr.get_coverage());
        $display("Mode: %0.2f%%", cg_stimulus.cp_mode.get_coverage());
        $display("Cross: %0.2f%%", cg_stimulus.cross_addr_mode.get_coverage());
    endtask
endclass

module test_coverage_driven;
    initial begin
        CoverageDrivenGenerator gen;
        gen = new();
        gen.run_coverage_driven_test(100);
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Advanced Coverage Techniques}
%----------------------------------------------------------------------------

\begin{lstlisting}
// Generic coverage for parameterized designs
class GenericCoverage #(parameter ADDR_WIDTH = 32, DATA_WIDTH = 32);
    bit [ADDR_WIDTH-1:0] addr;
    bit [DATA_WIDTH-1:0] data;

    covergroup cg_generic;
        cp_addr: coverpoint addr {
            bins low    = {[0:(2**(ADDR_WIDTH-1))-1]};
            bins high   = {[2**(ADDR_WIDTH-1):2**ADDR_WIDTH-1]};
        }

        cp_data_msb: coverpoint data[DATA_WIDTH-1];
        cp_data_lsb: coverpoint data[0];
    endgroup

    function new();
        cg_generic = new();
    endfunction
endclass

// Coverage callbacks for advanced analysis
class CoverageCallbacks;
    covergroup cg_with_callbacks;
        cp_value: coverpoint value {
            bins low  = {[0:49]};
            bins mid  = {[50:99]};
            bins high = {[100:255]};
        }
    endgroup

    int value;
    int coverage_hits[$];

    function new();
        cg_with_callbacks = new();
    endfunction

    function void sample_and_track(int val);
        value = val;
        cg_with_callbacks.sample();
        coverage_hits.push_back(val);

        // Analyze coverage holes
        if (coverage_hits.size() > 20) begin
            analyze_coverage_holes();
        end
    endfunction

    function void analyze_coverage_holes();
        int low_count = 0, mid_count = 0, high_count = 0;

        foreach (coverage_hits[i]) begin
            if (coverage_hits[i] < 50) low_count++;
            else if (coverage_hits[i] < 100) mid_count++;
            else high_count++;
        end

        $display("\n=== Coverage Distribution ===");
        $display("Low bins:  %0d hits", low_count);
        $display("Mid bins:  %0d hits", mid_count);
        $display("High bins: %0d hits", high_count);

        // Identify holes
        if (low_count < 5)
            $display("WARNING: Low coverage in low range!");
        if (mid_count < 5)
            $display("WARNING: Low coverage in mid range!");
        if (high_count < 5)
            $display("WARNING: Low coverage in high range!");
    endfunction
endclass

// Coverage for state machines
typedef enum {IDLE, ACTIVE, WAIT, ERROR, DONE} state_t;

class StateMachineCoverage;
    state_t current_state, prev_state;

    covergroup cg_fsm;
        cp_state: coverpoint current_state;

        // State transitions
        cp_transitions: coverpoint current_state {
            bins idle_to_active = (IDLE => ACTIVE);
            bins active_to_wait = (ACTIVE => WAIT);
            bins wait_to_active = (WAIT => ACTIVE);
            bins any_to_error   = (IDLE, ACTIVE, WAIT => ERROR);
            bins error_to_idle  = (ERROR => IDLE);
            bins active_to_done = (ACTIVE => DONE);
            bins done_to_idle   = (DONE => IDLE);

            // Illegal transitions
            illegal_bins bad_trans = (DONE => ACTIVE);
        }

        // Multistate sequences
        cp_sequences: coverpoint current_state {
            bins normal_flow = (IDLE => ACTIVE => WAIT => ACTIVE => DONE);
            bins error_recovery = (ACTIVE => ERROR => IDLE => ACTIVE);
            bins quick_complete = (IDLE => ACTIVE => DONE);
        }
    endgroup

    function new();
        cg_fsm = new();
    endfunction

    function void update_state(state_t new_state);
        prev_state = current_state;
        current_state = new_state;
        cg_fsm.sample();
        $display("State: %s -> %s (Coverage: %0.2f%%)",
                 prev_state.name(), current_state.name(),
                 cg_fsm.get_coverage());
    endfunction
endclass

// Example usage
module test_advanced_coverage;
    initial begin
        GenericCoverage#(8, 16) gen_cov;
        CoverageCallbacks cov_cb;
        StateMachineCoverage fsm_cov;

        // Test generic coverage
        gen_cov = new();
        gen_cov.addr = 8'h7F;
        gen_cov.data = 16'hABCD;
        gen_cov.cg_generic.sample();

        // Test coverage with callbacks
        cov_cb = new();
        repeat(30) begin
            cov_cb.sample_and_track($urandom_range(0, 255));
        end

        // Test FSM coverage
        fsm_cov = new();
        fsm_cov.update_state(IDLE);
        fsm_cov.update_state(ACTIVE);
        fsm_cov.update_state(WAIT);
        fsm_cov.update_state(ACTIVE);
        fsm_cov.update_state(DONE);
        fsm_cov.update_state(IDLE);

        $display("\nFinal FSM Coverage: %0.2f%%",
                 fsm_cov.cg_fsm.get_coverage());
    end
endmodule
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 54: Comprehensive Protocol Coverage}

Create a coverage model for an AXI4 protocol with:
\begin{itemize}
    \item Coverpoints for address, burst length, burst size, burst type
    \item Cross coverage for all valid combinations
    \item Illegal bins for protocol violations
    \item Transition coverage for AWVALID/AWREADY handshaking
    \item Coverage options to ensure at least 10 hits per bin
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 55: Coverage-Driven Constraint Tuning}

Implement a self-adjusting generator that:
\begin{itemize}
    \item Monitors coverage in real-time
    \item Automatically adjusts constraint weights based on coverage holes
    \item Implements at least 3 different stimulus modes
    \item Provides coverage closure report showing how holes were filled
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 56: Hierarchical Coverage}

Design a hierarchical coverage structure for a complete SoC:
\begin{itemize}
    \item Top-level covergroup for system-level scenarios
    \item Component-level covergroups for each IP block
    \item Cross-hierarchy coverage relationships
    \item Methods to merge and report coverage at different levels
\end{itemize}
\end{exercisebox}

\begin{quizbox}
\textbf{Quiz 19: Advanced Coverage}

\begin{enumerate}
    \item What is the difference between \texttt{illegal\_bins} and \texttt{ignore\_bins}?
    \item How does \texttt{option.at\_least} affect coverage calculation?
    \item What does cross coverage measure that individual coverpoints cannot?
    \item When would you use transition bins instead of simple value bins?
    \item How can coverage feedback be used to improve stimulus generation?
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
    \item \texttt{illegal\_bins}: Hit causes error/warning; represents illegal scenarios. \texttt{ignore\_bins}: Excluded from coverage calculation; represents don't-care scenarios
    \item Sets minimum hit count for 100\% coverage; bin with fewer hits counts as uncovered; ensures robust verification
    \item Interactions between multiple variables; corner cases from combinations; individual coverpoints only measure single dimensions
    \item When order of values matters; state machine transitions; protocol sequences; temporal relationships are important
    \item Analyze uncovered bins; adjust constraints to target holes; weight distributions toward low-coverage areas; iterative refinement
\end{enumerate}
\end{quizbox}

\begin{warningbox}
\textbf{Common Coverage Pitfalls:}
\begin{itemize}
    \item Over-specification: Too many bins leading to uncloseable coverage
    \item Under-specification: Missing important corner cases
    \item Ignoring cross coverage: Missing interaction bugs
    \item Not using coverage feedback: Random stimulus may never hit some bins
    \item Illegal bin errors: Ensure constraints prevent illegal scenarios
\end{itemize}
\end{warningbox}

%============================================================================
\section{Introduction to UVM (Universal Verification Methodology)}
%============================================================================

UVM is an industry-standard methodology for SystemVerilog verification. It provides a framework, base classes, and best practices for building reusable, scalable verification environments.

%----------------------------------------------------------------------------
\subsection{UVM Fundamentals}
%----------------------------------------------------------------------------

UVM is built on several key concepts: hierarchy, phases, configuration, and reusability.

\begin{lstlisting}
// Basic UVM includes - required for all UVM testbenches
`include "uvm_macros.svh"
import uvm_pkg::*;

// Simple UVM component example
class my_component extends uvm_component;
    // Register with factory
    `uvm_component_utils(my_component)

    // Constructor
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    // Build phase - construct sub-components
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        `uvm_info(get_type_name(), "Build phase executing", UVM_LOW)
    endfunction

    // Connect phase - connect components together
    virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        `uvm_info(get_type_name(), "Connect phase executing", UVM_LOW)
    endfunction

    // Run phase - main execution
    virtual task run_phase(uvm_phase phase);
        `uvm_info(get_type_name(), "Run phase executing", UVM_LOW)
        #100ns;
    endtask
endclass

// Simple UVM test
class my_test extends uvm_test;
    `uvm_component_utils(my_test)

    my_component comp;

    function new(string name = "my_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        comp = my_component::type_id::create("comp", this);
    endfunction

    virtual task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        `uvm_info(get_type_name(), "Test starting", UVM_LOW)
        #500ns;
        `uvm_info(get_type_name(), "Test ending", UVM_LOW)
        phase.drop_objection(this);
    endtask
endclass

// Top-level module
module top;
    initial begin
        run_test("my_test");
    end
endmodule
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{UVM Phases}
%----------------------------------------------------------------------------

UVM defines a standardized execution flow through phases. Understanding phases is critical for proper component initialization and coordination.

\begin{lstlisting}
class phase_demo extends uvm_component;
    `uvm_component_utils(phase_demo)

    function new(string name, uvm_component parent);
        super.new(name, parent);
        `uvm_info(get_type_name(), "Constructor called", UVM_LOW)
    endfunction

    // 1. Build Phase (bottom-up)
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        `uvm_info(get_type_name(),
            "BUILD: Create and configure sub-components", UVM_MEDIUM)
    endfunction

    // 2. Connect Phase (bottom-up)
    virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        `uvm_info(get_type_name(),
            "CONNECT: Link components via TLM ports", UVM_MEDIUM)
    endfunction

    // 3. End of Elaboration (bottom-up)
    virtual function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        `uvm_info(get_type_name(),
            "END_ELAB: Hierarchy is complete", UVM_MEDIUM)
    endfunction

    // 4. Start of Simulation (bottom-up)
    virtual function void start_of_simulation_phase(uvm_phase phase);
        super.start_of_simulation_phase(phase);
        `uvm_info(get_type_name(),
            "START_SIM: Display topology, open files", UVM_MEDIUM)
    endfunction

    // 5. Run Phase (parallel for all components)
    virtual task run_phase(uvm_phase phase);
        `uvm_info(get_type_name(),
            "RUN: Main execution phase", UVM_MEDIUM)
        #50ns;
    endtask

    // 6. Extract Phase (bottom-up)
    virtual function void extract_phase(uvm_phase phase);
        super.extract_phase(phase);
        `uvm_info(get_type_name(),
            "EXTRACT: Collect results", UVM_MEDIUM)
    endfunction

    // 7. Check Phase (bottom-up)
    virtual function void check_phase(uvm_phase phase);
        super.check_phase(phase);
        `uvm_info(get_type_name(),
            "CHECK: Verify results", UVM_MEDIUM)
    endfunction

    // 8. Report Phase (bottom-up)
    virtual function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        `uvm_info(get_type_name(),
            "REPORT: Display final statistics", UVM_MEDIUM)
    endfunction

    // 9. Final Phase (top-down)
    virtual function void final_phase(uvm_phase phase);
        super.final_phase(phase);
        `uvm_info(get_type_name(),
            "FINAL: Close files, cleanup", UVM_MEDIUM)
    endfunction
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{UVM Transaction and Sequence Item}
%----------------------------------------------------------------------------

Transactions are the fundamental unit of communication in UVM. They represent data to be transferred between components.

\begin{lstlisting}
// Transaction class
class simple_transaction extends uvm_sequence_item;
    // Transaction fields
    rand bit [31:0] addr;
    rand bit [31:0] data;
    rand bit        write;  // 1 = write, 0 = read
    bit [31:0]      response_data;

    // Constraints
    constraint c_addr { addr[1:0] == 2'b00; }  // Word aligned

    // UVM automation macros
    `uvm_object_utils_begin(simple_transaction)
        `uvm_field_int(addr, UVM_ALL_ON)
        `uvm_field_int(data, UVM_ALL_ON)
        `uvm_field_int(write, UVM_ALL_ON)
        `uvm_field_int(response_data, UVM_ALL_ON | UVM_NOCOMPARE)
    `uvm_object_utils_end

    // Constructor
    function new(string name = "simple_transaction");
        super.new(name);
    endfunction

    // Convert to string for printing
    virtual function string convert2string();
        return $sformatf("addr=0x%0h, data=0x%0h, write=%0b, resp=0x%0h",
                         addr, data, write, response_data);
    endfunction
endclass

// Sequence - generates transactions
class simple_sequence extends uvm_sequence#(simple_transaction);
    `uvm_object_utils(simple_sequence)

    function new(string name = "simple_sequence");
        super.new(name);
    endfunction

    virtual task body();
        simple_transaction tr;

        // Generate 5 random transactions
        repeat(5) begin
            tr = simple_transaction::type_id::create("tr");
            start_item(tr);
            assert(tr.randomize());
            `uvm_info(get_type_name(),
                $sformatf("Sending: %s", tr.convert2string()), UVM_MEDIUM)
            finish_item(tr);
        end

        // Generate specific write transaction
        tr = simple_transaction::type_id::create("tr");
        start_item(tr);
        assert(tr.randomize() with {
            write == 1;
            addr == 32'h1000;
            data == 32'hDEADBEEF;
        });
        `uvm_info(get_type_name(),
            $sformatf("Sending directed: %s", tr.convert2string()), UVM_MEDIUM)
        finish_item(tr);
    endtask
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{UVM Driver}
%----------------------------------------------------------------------------

The driver receives transactions from the sequencer and drives them onto the DUT interface.

\begin{lstlisting}
// Interface for the DUT
interface simple_if(input logic clk, input logic rst_n);
    logic [31:0] addr;
    logic [31:0] wdata;
    logic [31:0] rdata;
    logic        write;
    logic        valid;
    logic        ready;
endinterface

// UVM Driver
class simple_driver extends uvm_driver#(simple_transaction);
    `uvm_component_utils(simple_driver)

    virtual simple_if vif;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Get virtual interface from config DB
        if (!uvm_config_db#(virtual simple_if)::get(this, "", "vif", vif))
            `uvm_fatal(get_type_name(), "Virtual interface not found!")
    endfunction

    virtual task run_phase(uvm_phase phase);
        simple_transaction tr;

        // Initialize signals
        vif.valid <= 0;
        vif.addr  <= 0;
        vif.wdata <= 0;
        vif.write <= 0;

        forever begin
            // Get next transaction from sequencer
            seq_item_port.get_next_item(tr);

            // Drive transaction onto interface
            drive_transaction(tr);

            // Indicate completion
            seq_item_port.item_done();
        end
    endtask

    virtual task drive_transaction(simple_transaction tr);
        `uvm_info(get_type_name(),
            $sformatf("Driving: %s", tr.convert2string()), UVM_HIGH)

        @(posedge vif.clk);
        vif.addr  <= tr.addr;
        vif.write <= tr.write;
        if (tr.write)
            vif.wdata <= tr.data;
        vif.valid <= 1;

        // Wait for ready
        @(posedge vif.clk);
        while (!vif.ready) @(posedge vif.clk);

        // Capture read data if read transaction
        if (!tr.write)
            tr.response_data = vif.rdata;

        vif.valid <= 0;
        @(posedge vif.clk);
    endtask
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{UVM Monitor}
%----------------------------------------------------------------------------

The monitor observes the DUT interface and reports transactions to other components via analysis ports.

\begin{lstlisting}
class simple_monitor extends uvm_monitor;
    `uvm_component_utils(simple_monitor)

    virtual simple_if vif;

    // Analysis port to broadcast observed transactions
    uvm_analysis_port#(simple_transaction) ap;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        ap = new("ap", this);
        if (!uvm_config_db#(virtual simple_if)::get(this, "", "vif", vif))
            `uvm_fatal(get_type_name(), "Virtual interface not found!")
    endfunction

    virtual task run_phase(uvm_phase phase);
        simple_transaction tr;

        forever begin
            // Wait for valid transaction
            @(posedge vif.clk);
            if (vif.valid && vif.ready) begin
                tr = simple_transaction::type_id::create("tr");

                // Capture transaction
                tr.addr = vif.addr;
                tr.write = vif.write;
                if (tr.write)
                    tr.data = vif.wdata;
                else
                    tr.response_data = vif.rdata;

                `uvm_info(get_type_name(),
                    $sformatf("Observed: %s", tr.convert2string()), UVM_HIGH)

                // Broadcast to subscribers
                ap.write(tr);
            end
        end
    endtask
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Complete UVM Environment Example}
%----------------------------------------------------------------------------

\begin{lstlisting}
// UVM Agent - contains driver, sequencer, monitor
class simple_agent extends uvm_agent;
    `uvm_component_utils(simple_agent)

    simple_driver    driver;
    uvm_sequencer#(simple_transaction) sequencer;
    simple_monitor   monitor;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        monitor = simple_monitor::type_id::create("monitor", this);

        // Only create driver/sequencer if active
        if (get_is_active() == UVM_ACTIVE) begin
            driver = simple_driver::type_id::create("driver", this);
            sequencer = uvm_sequencer#(simple_transaction)::type_id::create(
                "sequencer", this);
        end
    endfunction

    virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        if (get_is_active() == UVM_ACTIVE) begin
            driver.seq_item_port.connect(sequencer.seq_item_export);
        end
    endfunction
endclass

// UVM Environment - top-level container
class simple_env extends uvm_env;
    `uvm_component_utils(simple_env)

    simple_agent agent;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        agent = simple_agent::type_id::create("agent", this);
    endfunction
endclass

// UVM Test
class simple_uvm_test extends uvm_test;
    `uvm_component_utils(simple_uvm_test)

    simple_env env;

    function new(string name = "simple_uvm_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = simple_env::type_id::create("env", this);
    endfunction

    virtual task run_phase(uvm_phase phase);
        simple_sequence seq;

        phase.raise_objection(this);

        seq = simple_sequence::type_id::create("seq");
        seq.start(env.agent.sequencer);

        #1000ns;

        phase.drop_objection(this);
    endtask

    virtual function void report_phase(uvm_phase phase);
        uvm_report_server svr;
        super.report_phase(phase);

        svr = uvm_report_server::get_server();
        if (svr.get_severity_count(UVM_FATAL) +
            svr.get_severity_count(UVM_ERROR) == 0) begin
            `uvm_info(get_type_name(), "** TEST PASSED **", UVM_NONE)
        end else begin
            `uvm_error(get_type_name(), "** TEST FAILED **")
        end
    endfunction
endclass
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 57: Build a UVM Testbench}

Create a complete UVM testbench for a simple FIFO:
\begin{itemize}
    \item Transaction with write/read operations
    \item Sequence generating various FIFO scenarios (full, empty, normal)
    \item Driver to drive FIFO interface
    \item Monitor to observe FIFO outputs
    \item Agent combining all components
    \item Test that runs the sequence
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 58: UVM Configuration}

Implement UVM configuration database usage:
\begin{itemize}
    \item Create configurable parameters (FIFO depth, data width)
    \item Use \texttt{uvm\_config\_db} to set/get configuration
    \item Support multiple configuration scenarios
    \item Demonstrate configuration override in tests
\end{itemize}
\end{exercisebox}

\begin{exercisebox}
\textbf{Exercise 59: UVM Reporting and Messaging}

Implement comprehensive UVM reporting:
\begin{itemize}
    \item Use all verbosity levels (UVM\_NONE to UVM\_DEBUG)
    \item Implement custom report catcher
    \item Add transaction recording with \texttt{uvm\_recorder}
    \item Create formatted reports with statistics
\end{itemize}
\end{exercisebox}

\begin{quizbox}
\textbf{Quiz 20: UVM Fundamentals}

\begin{enumerate}
    \item What is the purpose of the factory pattern in UVM?
    \item Why must you call \texttt{raise\_objection} in the run phase?
    \item What is the difference between \texttt{uvm\_component} and \texttt{uvm\_object}?
    \item How does a driver get transactions from a sequencer?
    \item What is the purpose of analysis ports in UVM?
\end{enumerate}

\textbf{Answers:}
\begin{enumerate}
    \item Enables object creation by type name; supports test-time type overrides; promotes reusability and flexibility
    \item Prevents simulation from ending prematurely; keeps run phase alive; must be paired with \texttt{drop\_objection}
    \item \texttt{uvm\_component}: Has hierarchy, phase support, location (e.g., driver, monitor). \texttt{uvm\_object}: Lightweight, no hierarchy (e.g., transactions, sequences)
    \item Via \texttt{seq\_item\_port.get\_next\_item()} which connects to sequencer's export; blocking call waits for sequence
    \item Broadcast transactions to multiple subscribers (scoreboard, coverage); one-to-many communication; decouples components
\end{enumerate}
\end{quizbox}

\begin{tipbox}
\textbf{UVM Best Practices:}
\begin{itemize}
    \item Always use factory registration (\texttt{`uvm\_component\_utils})
    \item Never call \texttt{new()} directly; use \texttt{type\_id::create()}
    \item Set virtual interfaces via \texttt{uvm\_config\_db}
    \item Use appropriate message verbosity levels
    \item Always balance \texttt{raise\_objection} / \texttt{drop\_objection}
    \item Leverage UVM field macros for common operations (copy, compare, print)
\end{itemize}
\end{tipbox}

%============================================================================
\section{UVM Advanced Components: Scoreboard, RAL, and Virtual Sequences}
%============================================================================

Advanced UVM components enable sophisticated verification strategies including self-checking, register abstraction, and coordinated multi-interface testing.

%----------------------------------------------------------------------------
\subsection{UVM Scoreboard with TLM}
%----------------------------------------------------------------------------

Scoreboards verify correctness by comparing actual DUT behavior against expected behavior using Transaction-Level Modeling (TLM).

\begin{lstlisting}
// Scoreboard with analysis imports
`uvm_analysis_imp_decl(_expected)
`uvm_analysis_imp_decl(_actual)

class uvm_scoreboard_example extends uvm_scoreboard;
    `uvm_component_utils(uvm_scoreboard_example)

    // Analysis imports for receiving transactions
    uvm_analysis_imp_expected#(simple_transaction, uvm_scoreboard_example) expected_export;
    uvm_analysis_imp_actual#(simple_transaction, uvm_scoreboard_example) actual_export;

    // Queues for storing transactions
    simple_transaction expected_q[$];
    simple_transaction actual_q[$];

    // Statistics
    int matches = 0;
    int mismatches = 0;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        expected_export = new("expected_export", this);
        actual_export = new("actual_export", this);
    endfunction

    // Receive expected transaction
    virtual function void write_expected(simple_transaction tr);
        simple_transaction tr_clone;
        $cast(tr_clone, tr.clone());
        expected_q.push_back(tr_clone);
        `uvm_info(get_type_name(),
            $sformatf("Received EXPECTED: %s", tr.convert2string()), UVM_HIGH)
        compare_transactions();
    endfunction

    // Receive actual transaction
    virtual function void write_actual(simple_transaction tr);
        simple_transaction tr_clone;
        $cast(tr_clone, tr.clone());
        actual_q.push_back(tr_clone);
        `uvm_info(get_type_name(),
            $sformatf("Received ACTUAL: %s", tr.convert2string()), UVM_HIGH)
        compare_transactions();
    endfunction

    // Compare transactions
    virtual function void compare_transactions();
        simple_transaction exp, act;

        while (expected_q.size() > 0 && actual_q.size() > 0) begin
            exp = expected_q.pop_front();
            act = actual_q.pop_front();

            if (exp.compare(act)) begin
                matches++;
                `uvm_info(get_type_name(),
                    $sformatf("MATCH #%0d: %s", matches, exp.convert2string()),
                    UVM_MEDIUM)
            end else begin
                mismatches++;
                `uvm_error(get_type_name(),
                    $sformatf("MISMATCH #%0d:\n  Expected: %s\n  Actual:   %s",
                              mismatches, exp.convert2string(), act.convert2string()))
            end
        end
    endfunction

    virtual function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        `uvm_info(get_type_name(),
            $sformatf("=== SCOREBOARD REPORT ===\nMatches: %0d\nMismatches: %0d",
                      matches, mismatches), UVM_LOW)

        if (mismatches > 0)
            `uvm_error(get_type_name(), "Test FAILED due to mismatches")
    endfunction
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Advanced Sequences: Layering and Virtual Sequences}
%----------------------------------------------------------------------------

Virtual sequences coordinate multiple sequences across different agents, enabling complex test scenarios.

\begin{lstlisting}
// Virtual sequence operating on multiple sequencers
class virtual_sequence extends uvm_sequence;
    `uvm_object_utils(virtual_sequence)
    `uvm_declare_p_sequencer(virtual_sequencer)

    simple_sequence seq_master;
    simple_sequence seq_slave;

    function new(string name = "virtual_sequence");
        super.new(name);
    endfunction

    virtual task body();
        `uvm_info(get_type_name(), "Virtual sequence starting", UVM_MEDIUM)

        // Create sequences
        seq_master = simple_sequence::type_id::create("seq_master");
        seq_slave = simple_sequence::type_id::create("seq_slave");

        // Run sequences in parallel on different sequencers
        fork
            seq_master.start(p_sequencer.master_sequencer);
            seq_slave.start(p_sequencer.slave_sequencer);
        join

        `uvm_info(get_type_name(), "Virtual sequence complete", UVM_MEDIUM)
    endtask
endclass

// Virtual sequencer
class virtual_sequencer extends uvm_sequencer;
    `uvm_component_utils(virtual_sequencer)

    uvm_sequencer#(simple_transaction) master_sequencer;
    uvm_sequencer#(simple_transaction) slave_sequencer;

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
endclass

// Layered sequence example
class protocol_sequence extends uvm_sequence#(simple_transaction);
    `uvm_object_utils(protocol_sequence)

    rand int num_transactions;
    constraint c_num { num_transactions inside {[5:20]}; }

    function new(string name = "protocol_sequence");
        super.new(name);
    endfunction

    virtual task body();
        repeat(num_transactions) begin
            `uvm_do_with(req, {
                write dist {1 := 70, 0 := 30};  // 70% writes, 30% reads
                addr inside {[32'h0:32'hFFF]};
            })
        end
    endtask
endclass

// Sequence library for test selection
class sequence_library_example extends uvm_sequence_library#(simple_transaction);
    `uvm_object_utils(sequence_library_example)
    `uvm_sequence_library_utils(sequence_library_example)

    function new(string name = "sequence_library_example");
        super.new(name);
        init_sequence_library();
    endfunction

    virtual function void init_sequence_library();
        add_sequence(simple_sequence::get_type());
        add_sequence(protocol_sequence::get_type());
        // Add more sequences as needed
    endfunction
endclass
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{UVM Register Abstraction Layer (RAL)}
%----------------------------------------------------------------------------

RAL provides a high-level API for accessing design registers, supporting both front-door and back-door access.

\begin{lstlisting}
// Register definition
class control_register extends uvm_reg;
    rand uvm_reg_field enable;
    rand uvm_reg_field mode;
    rand uvm_reg_field interrupt_mask;

    function new(string name = "control_register");
        super.new(name, 32, UVM_NO_COVERAGE);
    endfunction

    virtual function void build();
        enable = uvm_reg_field::type_id::create("enable");
        mode = uvm_reg_field::type_id::create("mode");
        interrupt_mask = uvm_reg_field::type_id::create("interrupt_mask");

        // Configure fields: parent, size, lsb_pos, access, volatile, reset, has_reset, is_rand, individually_accessible
        enable.configure(this, 1, 0, "RW", 0, 1'h0, 1, 1, 0);
        mode.configure(this, 2, 1, "RW", 0, 2'h0, 1, 1, 0);
        interrupt_mask.configure(this, 8, 8, "RW", 0, 8'hFF, 1, 1, 0);
    endfunction

    `uvm_object_utils(control_register)
endclass

// Register block
class register_block extends uvm_reg_block;
    rand control_register ctrl_reg;
    rand uvm_reg status_reg;

    function new(string name = "register_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    virtual function void build();
        // Create registers
        ctrl_reg = control_register::type_id::create("ctrl_reg");
        ctrl_reg.configure(this, null, "");
        ctrl_reg.build();

        // Create address map
        default_map = create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN);
        default_map.add_reg(ctrl_reg, 'h00, "RW");
    endfunction

    `uvm_object_utils(register_block)
endclass

// RAL adapter
class reg_adapter extends uvm_reg_adapter;
    `uvm_object_utils(reg_adapter)

    function new(string name = "reg_adapter");
        super.new(name);
    endfunction

    virtual function uvm_sequence_item reg2bus(const ref uvm_reg_bus_op rw);
        simple_transaction tr = simple_transaction::type_id::create("tr");
        tr.write = (rw.kind == UVM_WRITE);
        tr.addr = rw.addr;
        if (tr.write)
            tr.data = rw.data;
        return tr;
    endfunction

    virtual function void bus2reg(uvm_sequence_item bus_item,
                                   ref uvm_reg_bus_op rw);
        simple_transaction tr;
        if (!$cast(tr, bus_item)) begin
            `uvm_fatal("CAST_FAIL", "Failed to cast bus_item")
        end
        rw.kind = tr.write ? UVM_WRITE : UVM_READ;
        rw.addr = tr.addr;
        rw.data = tr.write ? tr.data : tr.response_data;
        rw.status = UVM_IS_OK;
    endfunction
endclass

// Using RAL in a test
class ral_test extends uvm_test;
    `uvm_component_utils(ral_test)

    register_block regmodel;
    simple_env env;

    function new(string name = "ral_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        // Create register model
        regmodel = register_block::type_id::create("regmodel");
        regmodel.build();
        regmodel.lock_model();

        env = simple_env::type_id::create("env", this);
    endfunction

    virtual function void connect_phase(uvm_phase phase);
        reg_adapter adapter = reg_adapter::type_id::create("adapter");

        // Connect RAL to sequencer
        regmodel.default_map.set_sequencer(env.agent.sequencer, adapter);
        regmodel.default_map.set_auto_predict(1);
    endfunction

    virtual task run_phase(uvm_phase phase);
        uvm_status_e status;
        uvm_reg_data_t data;

        phase.raise_objection(this);

        // Write to control register
        regmodel.ctrl_reg.write(status, 32'h0000_0105);
        `uvm_info(get_type_name(), "Wrote to control register", UVM_LOW)

        // Read back
        regmodel.ctrl_reg.read(status, data);
        `uvm_info(get_type_name(),
            $sformatf("Read from control register: 0x%0h", data), UVM_LOW)

        // Check field values
        if (regmodel.ctrl_reg.enable.get() == 1)
            `uvm_info(get_type_name(), "Enable bit is set", UVM_LOW)

        #500ns;
        phase.drop_objection(this);
    endtask
endclass
\end{lstlisting}

\begin{exercisebox}
\textbf{Exercise 60: Build a Scoreboard with Predictor}

Create an intelligent scoreboard that:
\begin{itemize}
    \item Uses a reference model to predict expected outputs
    \item Supports out-of-order transaction comparison
    \item Implements timeout detection for missing transactions
    \item Provides detailed mismatch analysis
\end{itemize}
\end{exercisebox}

%============================================================================
\section{Advanced Interface Techniques and Protocols}
%============================================================================

%----------------------------------------------------------------------------
\subsection{Parameterized Interfaces}
%----------------------------------------------------------------------------

\begin{lstlisting}
// Parameterized interface for flexible protocol implementation
interface generic_bus_if #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32,
    parameter HAS_PARITY = 1
)(input logic clk, input logic rst_n);

    logic [ADDR_WIDTH-1:0] addr;
    logic [DATA_WIDTH-1:0] wdata;
    logic [DATA_WIDTH-1:0] rdata;
    logic                  valid;
    logic                  ready;
    logic                  parity;

    // Modport for master
    modport master (
        output addr, wdata, valid,
        input  rdata, ready, parity
    );

    // Modport for slave
    modport slave (
        input  addr, wdata, valid,
        output rdata, ready, parity
    );

    // Protocol checker as clocking block
    clocking cb_monitor @(posedge clk);
        input addr, wdata, rdata, valid, ready;
    endclocking

    // Assertions
    property p_valid_stable;
        @(posedge clk) disable iff (!rst_n)
        (valid && !ready) |=> $stable(valid) && $stable(addr);
    endproperty

    assert property (p_valid_stable)
        else $error("Valid/Address not stable during wait");
endinterface
\end{lstlisting}

%============================================================================
\section{Performance Optimization and Debugging}
%============================================================================

%----------------------------------------------------------------------------
\subsection{Simulation Performance Techniques}
%----------------------------------------------------------------------------

\begin{lstlisting}
// Efficient coding practices
class optimized_driver extends uvm_driver#(simple_transaction);
    `uvm_component_utils(optimized_driver)

    virtual simple_if vif;
    simple_transaction trans_queue[$];  // Queue for pipelining

    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction

    // Use non-blocking assignments for better performance
    virtual task drive_optimized(simple_transaction tr);
        // Minimize clock edge waits
        @(posedge vif.clk);
        vif.addr = tr.addr;      // Non-blocking in sequential block
        vif.wdata = tr.data;
        vif.valid = 1;

        // Fork off independent monitoring
        fork
            wait_for_ready();
        join_none
    endtask

    task wait_for_ready();
        while (!vif.ready) @(posedge vif.clk);
        vif.valid = 0;
    endtask
endclass

// Constrained random optimization
class optimized_transaction extends uvm_sequence_item;
    rand bit [31:0] addr;
    rand bit [31:0] data;

    // Use randc for better distribution (cycles through all values)
    randc bit [7:0] tag;

    // Minimize constraint complexity
    constraint c_addr {
        addr[1:0] == 2'b00;  // Simple bitwise constraint
        // Avoid: addr % 4 == 0;  // Division is slower
    }

    // Pre-calculate complex constraints
    constraint c_data {
        data dist {[0:100] := 70, [101:1000] := 30};
    }

    `uvm_object_utils(optimized_transaction)
endclass
\end{lstlisting}

%============================================================================
\section{Real-World Verification: Complete AXI4-Lite Testbench}
%============================================================================

\begin{lstlisting}
// Complete AXI4-Lite transaction
class axi4_lite_transaction extends uvm_sequence_item;
    rand bit [31:0] awaddr;
    rand bit [31:0] wdata;
    rand bit [3:0]  wstrb;
    rand bit [31:0] araddr;
    bit [31:0]      rdata;
    bit [1:0]       bresp;
    bit [1:0]       rresp;
    rand bit        is_write;

    constraint c_aligned { awaddr[1:0] == 0; araddr[1:0] == 0; }
    constraint c_strb { wstrb != 4'b0000; }

    `uvm_object_utils_begin(axi4_lite_transaction)
        `uvm_field_int(awaddr, UVM_ALL_ON)
        `uvm_field_int(wdata, UVM_ALL_ON)
        `uvm_field_int(is_write, UVM_ALL_ON)
    `uvm_object_utils_end

    function new(string name = "axi4_lite_transaction");
        super.new(name);
    endfunction
endclass

// AXI4-Lite sequence with realistic patterns
class axi4_burst_sequence extends uvm_sequence#(axi4_lite_transaction);
    `uvm_object_utils(axi4_burst_sequence)

    rand int num_writes;
    rand int num_reads;
    bit [31:0] base_addr = 32'h1000;

    constraint c_transactions {
        num_writes inside {[5:20]};
        num_reads inside {[5:20]};
    }

    function new(string name = "axi4_burst_sequence");
        super.new(name);
    endfunction

    virtual task body();
        // Write phase
        for (int i = 0; i < num_writes; i++) begin
            `uvm_do_with(req, {
                is_write == 1;
                awaddr == base_addr + (i * 4);
                wdata == 32'hA000_0000 + i;
            })
        end

        // Read phase
        for (int i = 0; i < num_reads; i++) begin
            `uvm_do_with(req, {
                is_write == 0;
                araddr == base_addr + (i * 4);
            })
        end
    endtask
endclass
\end{lstlisting}

%============================================================================
\section{Best Practices and Interview Preparation}
%============================================================================

%----------------------------------------------------------------------------
\subsection{SystemVerilog Interview Topics}
%----------------------------------------------------------------------------

\begin{quizbox}
\textbf{Quiz 21: Expert-Level Interview Questions}

\begin{enumerate}
    \item Explain the difference between program blocks and modules for testbenches
    \item What are the four-state and two-state data types? When would you use each?
    \item How does fork-join\_none differ from fork-join and fork-join\_any?
    \item Explain how the UVM factory pattern enables test flexibility
    \item What is the difference between assertions in immediate vs concurrent form?
    \item How do you prevent race conditions between testbench and DUT?
    \item Explain covergroup sampling: automatic vs explicit
    \item What are the phases of UVM and their execution order?
    \item How does constraint solving with cyclic dependencies work?
    \item Explain the difference between virtual and pure virtual functions
\end{enumerate}

\textbf{Sample Answers:}
\begin{enumerate}
    \item \textbf{Program vs Module}: Programs execute in reactive region (after NBA), preventing races. Modules execute in active region. Programs are better for testbenches.

    \item \textbf{Four-state vs Two-state}: Four-state (logic, reg) support X/Z for hardware modeling. Two-state (bit, int) faster simulation, used in testbenches.

    \item \textbf{Fork-join variants}: join waits all processes; join\_any waits first; join\_none spawns and continues immediately.

    \item \textbf{UVM Factory}: Enables type override at runtime without modifying code. test can replace transaction type globally via set\_type\_override().

    \item \textbf{Immediate vs Concurrent}: Immediate assertions execute procedurally like if statement. Concurrent use temporal logic, evaluated on clock edges.
\end{enumerate}
\end{quizbox}

\begin{tipbox}
\textbf{Key Best Practices:}
\begin{itemize}
    \item \textbf{Constraint Strategy}: Layer constraints (base + scenario) for flexibility
    \item \textbf{Coverage Goals}: Aim for 100\% code coverage, 90\%+ functional coverage
    \item \textbf{Assertions}: Add at module boundaries and for protocol checks
    \item \textbf{Reusability}: Use interfaces, classes, and packages for modularity
    \item \textbf{Debugging}: Use \$display with hierarchical names, waveform viewers
    \item \textbf{Performance}: Minimize randomization solve time, use efficient constraints
    \item \textbf{Documentation}: Comment complex constraints and coverage bins
    \item \textbf{Version Control}: Modular testbench enables team collaboration
\end{itemize}
\end{tipbox}

\begin{exercisebox}
\textbf{Exercise 61-65: Capstone Projects}

\textbf{61. Complete UART Verification Environment}
\begin{itemize}
    \item Full UVM testbench with configurable baud rate
    \item Randomized packet generation with parity/frame errors
    \item Protocol checker with assertions
    \item 100\% functional coverage plan
\end{itemize}

\textbf{62. AXI4 Master-Slave Verification}
\begin{itemize}
    \item Multi-master, multi-slave environment
    \item Virtual sequences for complex scenarios
    \item RAL model for register access
    \item Performance analysis (bandwidth, latency)
\end{itemize}

\textbf{63. Cache Coherency Protocol Verification}
\begin{itemize}
    \item MESI protocol implementation
    \item Random multi-core access patterns
    \item Assertion-based verification of coherency
    \item Coverage of all state transitions
\end{itemize}

\textbf{64. Network Switch Testbench}
\begin{itemize}
    \item Multiple input/output ports
    \item Packet routing with priority queues
    \item Back-pressure handling
    \item Traffic generator with realistic patterns
\end{itemize}

\textbf{65. DDR Controller Verification}
\begin{itemize}
    \item Memory model with timing checks
    \item Command sequence verification
    \item Refresh and power-down scenarios
    \item Constraint-driven address generation
\end{itemize}
\end{exercisebox}

\begin{warningbox}
\textbf{Common Verification Mistakes to Avoid:}
\begin{itemize}
    \item Not randomizing constraint ordering (use solve-before)
    \item Forgetting to clone transactions in scoreboard
    \item Missing objection raise/drop pairs in UVM
    \item Not using virtual interfaces (causes NULL pointer errors)
    \item Inadequate reset handling in drivers/monitors
    \item Ignoring X-propagation in four-state logic
    \item Over-constraining randomization (no solution space)
    \item Not verifying assertions are actually checked
\end{itemize}
\end{warningbox}

\vfill
\begin{center}
\rule{0.8\textwidth}{0.4pt}\\[0.5cm]
{\Large\textbf{Congratulations!}}\\[0.3cm]
{\large You have completed the Comprehensive SystemVerilog Guide}\\[0.2cm]
\normalsize
This guide covered 30 sections from beginner to expert level,\\
including 65+ exercises and 100+ code examples.\\[0.3cm]
\textit{Continue practicing with real-world projects to master verification!}\\[0.5cm]
\rule{0.8\textwidth}{0.4pt}
\end{center}

\end{document}
